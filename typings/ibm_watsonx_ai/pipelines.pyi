"""
This type stub file was generated by pyright.
"""

from typing import Literal, TYPE_CHECKING
from ibm_watsonx_ai.wml_resource import WMLResource
from pandas import DataFrame
from ibm_watsonx_ai import APIClient

if TYPE_CHECKING:
    ...
class Pipelines(WMLResource):
    """Store and manage pipelines."""
    ConfigurationMetaNames = ...
    def __init__(self, client: APIClient) -> None:
        ...
    
    def store(self, meta_props: dict, **kwargs) -> dict:
        """Create a pipeline.

        :param meta_props: metadata of the pipeline configuration. To see available meta names, use:

            .. code-block:: python

                client.pipelines.ConfigurationMetaNames.get()

        :type meta_props: dict

        :return: stored pipeline metadata
        :rtype: dict

        **Example:**

        .. code-block:: python

            metadata = {
                client.pipelines.ConfigurationMetaNames.NAME: "my_training_definition",
                client.pipelines.ConfigurationMetaNames.DOCUMENT: {
                    "doc_type": "pipeline",
                    "version": "2.0",
                    "primary_pipeline": "dlaas_only",
                    "pipelines": [
                        {
                            "id": "dlaas_only",
                            "runtime_ref": "hybrid",
                            "nodes": [
                                {
                                    "id": "training",
                                    "type": "model_node",
                                    "op": "dl_train",
                                    "runtime_ref": "DL",
                                    "inputs": [],
                                    "outputs": [],
                                    "parameters": {
                                        "name": "tf-mnist",
                                        "description": "Simple MNIST model implemented in TF",
                                        "command": (
                                            "python3 convolutional_network.py "
                                            "--trainImagesFile ${DATA_DIR}/train-images-idx3-ubyte.gz "
                                            "--trainLabelsFile ${DATA_DIR}/train-labels-idx1-ubyte.gz "
                                            "--testImagesFile ${DATA_DIR}/t10k-images-idx3-ubyte.gz "
                                            "--testLabelsFile ${DATA_DIR}/t10k-labels-idx1-ubyte.gz "
                                            "--learningRate 0.001 --trainingIters 6000"
                                        ),
                                        "compute": {"name": "k80", "nodes": 1},
                                        "training_lib_href": "/v4/libraries/64758251-bt01-4aa5-a7ay-72639e2ff4d2/content",
                                    },
                                    "target_bucket": "wml-dev-results",
                                }
                            ],
                        }
                    ],
                },
            }

            pipeline_details = client.pipelines.store(
                training_definition_filepath, meta_props=metadata
            )

        """
        ...
    
    async def astore(self, meta_props: dict, **kwargs) -> dict:
        """Create a pipeline asynchronously.

        :param meta_props: metadata of the pipeline configuration. To see available meta names, use:

            .. code-block:: python

                client.pipelines.ConfigurationMetaNames.get()

        :type meta_props: dict

        :return: stored pipeline metadata
        :rtype: dict

        **Example:**

        .. code-block:: python

            metadata = {
                client.pipelines.ConfigurationMetaNames.NAME: "my_training_definition",
                client.pipelines.ConfigurationMetaNames.DOCUMENT: {
                    "doc_type": "pipeline",
                    "version": "2.0",
                    "primary_pipeline": "dlaas_only",
                    "pipelines": [
                        {
                            "id": "dlaas_only",
                            "runtime_ref": "hybrid",
                            "nodes": [
                                {
                                    "id": "training",
                                    "type": "model_node",
                                    "op": "dl_train",
                                    "runtime_ref": "DL",
                                    "inputs": [],
                                    "outputs": [],
                                    "parameters": {
                                        "name": "tf-mnist",
                                        "description": "Simple MNIST model implemented in TF",
                                        "command": (
                                            "python3 convolutional_network.py "
                                            "--trainImagesFile ${DATA_DIR}/train-images-idx3-ubyte.gz "
                                            "--trainLabelsFile ${DATA_DIR}/train-labels-idx1-ubyte.gz "
                                            "--testImagesFile ${DATA_DIR}/t10k-images-idx3-ubyte.gz "
                                            "--testLabelsFile ${DATA_DIR}/t10k-labels-idx1-ubyte.gz "
                                            "--learningRate 0.001 --trainingIters 6000"
                                        ),
                                        "compute": {"name": "k80", "nodes": 1},
                                        "training_lib_href": "/v4/libraries/64758251-bt01-4aa5-a7ay-72639e2ff4d2/content",
                                    },
                                    "target_bucket": "wml-dev-results",
                                }
                            ],
                        }
                    ],
                },
            }

            pipeline_details = await client.pipelines.astore(
                training_definition_filepath, meta_props=metadata
            )

        """
        ...
    
    def create_revision(self, pipeline_id: str | None = ..., **kwargs) -> dict:
        """Create a new pipeline revision.

        :param pipeline_id: unique ID of the pipeline
        :type pipeline_id: str

        :return: details of the pipeline revision
        :rtype: dict

        **Example:**

        .. code-block:: python

            client.pipelines.create_revision(pipeline_id)

        """
        ...
    
    async def acreate_revision(self, pipeline_id: str) -> dict:
        """Create a new pipeline revision asynchronously.

        :param pipeline_id: unique ID of the pipeline
        :type pipeline_id: str

        :return: details of the pipeline revision
        :rtype: dict

        **Example:**

        .. code-block:: python

            await client.pipelines.acreate_revision(pipeline_id)

        """
        ...
    
    def update(self, pipeline_id: str | None = ..., changes: dict | None = ..., rev_id: str | None = ..., **kwargs) -> dict:
        """Update metadata of an existing pipeline.

        :param pipeline_id: unique ID of the pipeline to be updated
        :type pipeline_id: str
        :param changes: elements to be changed, where keys are ConfigurationMetaNames
        :type changes: dict
        :param rev_id: revision ID of the pipeline
        :type rev_id: str

        :return: metadata of the updated pipeline
        :rtype: dict

        **Example:**

        .. code-block:: python

            metadata = {
                client.pipelines.ConfigurationMetaNames.NAME: "updated_pipeline"
            }
            pipeline_details = client.pipelines.update(
                pipeline_id, changes=metadata
            )

        """
        ...
    
    async def aupdate(self, pipeline_id: str, changes: dict, rev_id: str | None = ...) -> dict:
        """Update metadata of an existing pipeline asynchronously.

        :param pipeline_id: unique ID of the pipeline to be updated
        :type pipeline_id: str
        :param changes: elements to be changed, where keys are ConfigurationMetaNames
        :type changes: dict

        :return: metadata of the updated pipeline
        :rtype: dict

        **Example:**

        .. code-block:: python

            metadata = {
                client.pipelines.ConfigurationMetaNames.NAME: "updated_pipeline"
            }
            pipeline_details = await client.pipelines.aupdate(
                pipeline_id, changes=metadata
            )

        """
        ...
    
    def delete(self, pipeline_id: str | None = ..., **kwargs) -> Literal["SUCCESS"]:
        """Delete a stored pipeline.

        :param pipeline_id: unique ID of the pipeline
        :type pipeline_id: str

        :return: status "SUCCESS" if deletion is successful
        :rtype: Literal["SUCCESS"]
        :raises: ApiRequestFailure if deletion failed

        **Example:**

        .. code-block:: python

            client.pipelines.delete(pipeline_id)

        """
        ...
    
    async def adelete(self, pipeline_id: str) -> Literal["SUCCESS"]:
        """Delete a stored pipeline asynchronously.

        :param pipeline_id: unique ID of the pipeline
        :type pipeline_id: str

        :return: status "SUCCESS" if deletion is successful
        :rtype: Literal["SUCCESS"]
        :raises: ApiRequestFailure if deletion failed

        **Example:**

        .. code-block:: python

            await client.pipelines.adelete(pipeline_id)

        """
        ...
    
    def get_details(self, pipeline_id: str | None = ..., limit: int | None = ..., asynchronous: bool | None = ..., get_all: bool | None = ..., pipeline_name: str | None = ..., **kwargs) -> dict:
        """Get metadata of stored pipeline(s).
        If neither pipeline ID nor pipeline name is specified, the metadata of all pipelines is returned.
        If only pipeline name is specified, metadata of pipelines with the name is returned (if any).

        :param pipeline_id: ID of the pipeline
        :type pipeline_id: str, optional
        :param limit: limit number of fetched records
        :type limit: int, optional
        :param asynchronous: if `True`, it will work as a generator
        :type asynchronous: bool, optional
        :param get_all: if `True`, it will get all entries in 'limited' chunks
        :type get_all: bool, optional
        :param pipeline_name: name of the pipeline, can be used only when `pipeline_id` is None
        :type pipeline_name: str, optional

        :return: metadata of pipeline(s)
        :rtype: dict (if ID is not None) or {"resources": [dict]} (if ID is None)

        **Example:**

        .. code-block:: python

            pipeline_details = client.pipelines.get_details(pipeline_id)
            pipeline_details = client.pipelines.get_details(
                pipeline_name="Sample_pipeline"
            )
            pipeline_details = client.pipelines.get_details()
            pipeline_details = client.pipelines.get_details(limit=100)
            pipeline_details = client.pipelines.get_details(limit=100, get_all=True)
            pipeline_details = []
            for entry in client.pipelines.get_details(
                limit=100, asynchronous=True, get_all=True
            ):
                pipeline_details.extend(entry)

        """
        ...
    
    async def aget_details(self, pipeline_id: str | None = ..., limit: int | None = ..., asynchronous: bool | None = ..., get_all: bool | None = ..., pipeline_name: str | None = ...) -> dict:
        """Get metadata of stored pipeline(s) asynchronously.
        If neither pipeline ID nor pipeline name is specified, the metadata of all pipelines is returned.
        If only pipeline name is specified, metadata of pipelines with the name is returned (if any).

        :param pipeline_id: ID of the pipeline
        :type pipeline_id: str, optional
        :param limit: limit number of fetched records
        :type limit: int, optional
        :param asynchronous: if `True`, it will work as a generator
        :type asynchronous: bool, optional
        :param get_all: if `True`, it will get all entries in 'limited' chunks
        :type get_all: bool, optional
        :param pipeline_name: name of the pipeline, can be used only when `pipeline_id` is None
        :type pipeline_name: str, optional

        :return: metadata of pipeline(s)
        :rtype: dict (if ID is not None) or {"resources": [dict]} (if ID is None)

        **Example:**

        .. code-block:: python

            pipeline_details = await client.pipelines.aget_details(pipeline_id)
            pipeline_details = await client.pipelines.aget_details(
                pipeline_name="Sample_pipeline"
            )
            pipeline_details = await client.pipelines.aget_details()
            pipeline_details = await client.pipelines.aget_details(limit=100)
            pipeline_details = await client.pipelines.aget_details(
                limit=100, get_all=True
            )
            pipeline_details = []
            for entry in await client.pipelines.aget_details(
                limit=100, asynchronous=True, get_all=True
            ):
                pipeline_details.extend(entry)

        """
        ...
    
    def get_revision_details(self, pipeline_id: str | None = ..., rev_id: str | None = ..., **kwargs) -> dict:
        """Get metadata of a pipeline revision.

        :param pipeline_id: ID of the stored pipeline
        :type pipeline_id: str

        :param rev_id: revision ID of the stored pipeline
        :type rev_id: str

        :return: revised metadata of the stored pipeline
        :rtype: dict

        **Example:**

        .. code-block:: python

            pipeline_details = client.pipelines.get_revision_details(
                pipeline_id, rev_id
            )

        .. note::
            `rev_id` parameter is not applicable in Cloud platform.
        """
        ...
    
    async def aget_revision_details(self, pipeline_id: str, rev_id: str) -> dict:
        """Get metadata of a pipeline revision.

        :param pipeline_id: ID of the stored pipeline
        :type pipeline_id: str

        :param rev_id: revision ID of the stored pipeline
        :type rev_id: str

        :return: revised metadata of the stored pipeline
        :rtype: dict

        **Example:**

        .. code-block:: python

            pipeline_details = await client.pipelines.aget_revision_details(
                pipeline_id, rev_id
            )

        .. note::
            `rev_id` parameter is not applicable in Cloud platform.
        """
        ...
    
    @staticmethod
    def get_href(pipeline_details: dict) -> str:
        """Get the href from pipeline details.

        :param pipeline_details: metadata of the stored pipeline
        :type pipeline_details: dict

        :return: href of the pipeline
        :rtype: str

        **Example:**

        .. code-block:: python

            pipeline_details = client.pipelines.get_details(pipeline_id)
            pipeline_href = client.pipelines.get_href(pipeline_details)

        """
        ...
    
    @staticmethod
    def get_id(pipeline_details: dict) -> str:
        """Get the pipeline ID from pipeline details.

        :param pipeline_details: metadata of the stored pipeline
        :type pipeline_details: dict

        :return: unique ID of the pipeline
        :rtype: str

        **Example:**

        .. code-block:: python

            pipeline_id = client.pipelines.get_id(pipeline_details)

        """
        ...
    
    def list(self, limit: int | None = ...) -> DataFrame:
        """List stored pipelines in a table format.

        :param limit: limit number of fetched records
        :type limit: int, optional

        :return: pandas.DataFrame with listed pipelines
        :rtype: pandas.DataFrame

        **Example:**

        .. code-block:: python

            client.pipelines.list()

        """
        ...
    
    def list_revisions(self, pipeline_id: str | None = ..., limit: int | None = ..., **kwargs) -> DataFrame:
        """List all revision for a given pipeline ID in a table format.

        :param pipeline_id: unique ID of the stored pipeline
        :type pipeline_id: str

        :param limit: limit number of fetched records
        :type limit: int, optional

        :return: pandas.DataFrame with listed revisions
        :rtype: pandas.DataFrame

        **Example:**

        .. code-block:: python

            client.pipelines.list_revisions(pipeline_id)

        """
        ...
    
    def clone(self, pipeline_id: str | None = ..., space_id: str | None = ..., action: str | None = ..., rev_id: str | None = ..., **kwargs) -> dict:
        ...
    


