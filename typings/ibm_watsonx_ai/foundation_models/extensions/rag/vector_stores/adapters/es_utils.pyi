"""
This type stub file was generated by pyright.
"""

import elasticsearch
from typing import Any, Optional
from ibm_watsonx_ai.utils.utils import is_lib_installed
from elasticsearch.helpers.vectorstore import RetrievalStrategy

if not is_lib_installed(ext := "langchain-elasticsearch"):
    ...
TEXT_FIELD = ...
class RetrievalOptions:
    """Retrieval options to be used when conducting hybrid search."""
    DENSE = ...
    SPARSE = ...
    BM25 = ...


class HybridStrategyElasticsearch(RetrievalStrategy):
    """Hybrid strategy to be used in `ElasticsearchVectorStore` to take advantage of hybrid search.

    :param retrieval_strategies: mapping containing retrieval type and its properties
    :type retrieval_strategies: dict[str, dict[str, Any]]

    :param use_rrf: whether to use Reciprocal Rank Fusion (rrf) ranker when combining multiple results search in hybrid approach.
                    For more details, please visit https://www.elastic.co/guide/en/elasticsearch/reference/current/rrf.html, defaults to False
    :type use_rrf: bool, optional

    :param rrf_params: rrf method's parameters, default to None
    :type rrf_params: dict, optional

    :param text_field: text field name, default to `text_field`
    :type text_field: str, optional

    **Example:**

    When no ranker method is explicitly specified, the weighted ranker is used with all weights equal to 1.
    To change the weight for particular strategy add `boost` field to retrieval type settings.

    .. code-block:: python

        from ibm_watsonx_ai.foundation_models.extensions.rag.vector_stores import (
            HybridStrategyElasticsearch,
            RetrievalOptions,
        )


        strategy = HybridStrategyElasticsearch(
            retrieval_strategies={
                RetrievalOptions.SPARSE: {"model_id": ".elser", "boost": 0.5},
                RetrievalOptions.BM25: {"boost": 1},
            }
        )


    Example with rrf ranker:

    .. code-block:: python

        from ibm_watsonx_ai.foundation_models.extensions.rag.vector_stores import (
            HybridStrategyElasticsearch,
            RetrievalOptions,
        )



        strategy=HybridStrategyElasticsearch(
            retrieval_strategies={
                RetrievalOptions.SPARSE: {"model_id": ".elser"},
                RetrievalOptions.BM25: {},
            },
            use_rrf=True
            rrf_params={"k": 50}
        )

    """
    _sparse_vector_field = ...
    _dense_vector_field = ...
    _tokens_field = ...
    _sparse_model_id = ...
    _dense_model_id = ...
    def __init__(self, retrieval_strategies: dict[str, dict[str, Any]], use_rrf: bool = ..., rrf_params: dict | None = ..., text_field: str = ...) -> None:
        ...
    
    def before_index_creation(self, *, client: elasticsearch.Elasticsearch, text_field: str, vector_field: str) -> None:
        ...
    
    def es_mappings_settings(self, *, text_field: str, vector_field: str, num_dimensions: Optional[int]) -> tuple[dict[str, Any], dict[str, Any]]:
        ...
    
    def es_query(self, *, query: Optional[str], query_vector: Optional[list[float]], text_field: str, vector_field: str, k: int, num_candidates: int, filter: list[dict[str, Any]] = ...) -> dict[str, Any]:
        ...
    
    def needs_inference(self) -> bool:
        ...
    
    def to_dict(self) -> dict:
        """Serialize ``HybridStrategyElasticsearch`` into a dict that allows reconstruction using the ``from_dict`` class method.

        :return: dict for the from_dict initialization
        :rtype: dict
        """
        ...
    
    @classmethod
    def from_dict(cls, data: dict) -> HybridStrategyElasticsearch:
        """Creates ``HybridStrategyElasticsearch`` using only a primitive data type dict.

        :param data: dict in schema like the ``to_dict()`` method
        :type data: dict

        :return: reconstructed HybridStrategyElasticsearch
        :rtype: HybridStrategyElasticsearch
        """
        ...
    


