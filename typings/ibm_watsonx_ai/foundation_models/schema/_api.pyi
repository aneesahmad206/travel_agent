"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import Any, Literal, TYPE_CHECKING, Type, TypeVar
from ibm_watsonx_ai.utils.utils import StrEnum
from ibm_watsonx_ai.foundation_models.extensions.rag.retriever import RetrievalMethod

if TYPE_CHECKING:
    ...
T = TypeVar("T", bound="BaseSchema")
@dataclass
class BaseSchema:
    @classmethod
    def from_dict(cls: Type[T], data: dict[str, Any]) -> BaseSchema:
        ...
    
    def to_dict(self) -> dict[str, Any]:
        ...
    
    @classmethod
    def show(cls) -> None:
        """Displays a table with the parameter name, type, and example value."""
        ...
    
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Override this method in subclasses to provide example values for parameters."""
        ...
    


class TextGenDecodingMethod(StrEnum):
    GREEDY = ...
    SAMPLE = ...


@dataclass
class TextGenLengthPenalty(BaseSchema):
    decay_factor: float | None = ...
    start_index: int | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for TextGenLengthPenalty."""
        ...
    


@dataclass
class ReturnOptionProperties(BaseSchema):
    input_text: bool | None = ...
    generated_tokens: bool | None = ...
    input_tokens: bool | None = ...
    token_logprobs: bool | None = ...
    token_ranks: bool | None = ...
    top_n_tokens: bool | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for ReturnOptionProperties."""
        ...
    


@dataclass
class TextGenParameters(BaseSchema):
    decoding_method: str | TextGenDecodingMethod | None = ...
    length_penalty: dict | TextGenLengthPenalty | None = ...
    temperature: float | None = ...
    top_p: float | None = ...
    top_k: int | None = ...
    random_seed: int | None = ...
    repetition_penalty: float | None = ...
    min_new_tokens: int | None = ...
    max_new_tokens: int | None = ...
    stop_sequences: list[str] | None = ...
    time_limit: int | None = ...
    truncate_input_tokens: int | None = ...
    return_options: dict | ReturnOptionProperties | None = ...
    include_stop_sequence: bool | None = ...
    prompt_variables: dict | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for TextGenParameters."""
        ...
    


class TextChatResponseFormatType(StrEnum):
    JSON_OBJECT = ...
    JSON_SCHEMA = ...
    TEXT = ...


@dataclass
class TextChatResponseJsonSchema(BaseSchema):
    name: str | None = ...
    schema: dict | None = ...
    strict: bool | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for TextChatResponseJsonSchema."""
        ...
    


@dataclass
class TextChatResponseFormat(BaseSchema):
    type: str | TextChatResponseFormatType
    json_schema: dict | TextChatResponseJsonSchema | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for TextChatResponseFormat."""
        ...
    


@dataclass
class TextChatParameters(BaseSchema):
    frequency_penalty: float | None = ...
    logprobs: bool | None = ...
    top_logprobs: int | None = ...
    presence_penalty: float | None = ...
    response_format: dict | TextChatResponseFormat | None = ...
    temperature: float | None = ...
    max_tokens: int | None = ...
    max_completion_tokens: int | None = ...
    time_limit: int | None = ...
    top_p: float | None = ...
    n: int | None = ...
    logit_bias: dict | None = ...
    seed: int | None = ...
    stop: list[str] | None = ...
    guided_choice: list[str] | None = ...
    guided_regex: str | None = ...
    guided_grammar: str | None = ...
    guided_json: dict | None = ...
    chat_template_kwargs: dict | None = ...
    reasoning_effort: Literal["low", "medium", "high"] | None = ...
    include_reasoning: bool | None = ...
    repetition_penalty: float | None = ...
    length_penalty: float | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for TextChatParameters."""
        ...
    


@dataclass
class RerankReturnOptions(BaseSchema):
    top_n: int | None = ...
    inputs: bool | None = ...
    query: bool | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for RerankReturnOptions."""
        ...
    


@dataclass
class RerankParameters(BaseSchema):
    truncate_input_tokens: int | None = ...
    return_options: dict | RerankReturnOptions | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for RerankParameters."""
        ...
    


@dataclass
class TSForecastParameters(BaseSchema):
    r"""
    :param timestamp_column: A valid column in the data that should be treated as the timestamp.  if using calendar dates (simple integer time offsets are also allowed), users should consider using a format such as ISO 8601 that includes a UTC offset (e.g., '2024-10-18T01:09:21.454746+00:00'). This will avoid potential issues such as duplicate dates appearing due to daylight savings change overs. There are many date formats in existence and inferring the correct one can be a challenge so please do consider adhering to ISO 8601.
    :type timestamp_column: str

    :param prediction_length: The prediction length for the forecast. The service will return this many periods beyond the last timestamp in the inference data payload. If specified, prediction_length must be an integer >=1 and no more than the model default prediction length. When omitted the model default prediction_length will be used.
    :type prediction_length: int, optional

    :param id_columns: Columns that define a unique key for time series. This is similar to a compound primary key in a database table.
    :type id_columns: list[str], optional

    :param freq: A frequency indicator for the given timestamp_column. See https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#period-aliases for a description of the allowed values. If not provided, we will attempt to infer it from the data. Possible values: 0 ≤ length ≤ 100, Value must match regular expression ^\d+(B|D|W|M|Q|Y|h|min|s|ms|us|ns)$|^\s*$
    :type freq: str, optional

    :param target_columns: An array of column headings which constitute the target variables. These are the data that will be forecasted.
    :type target_columns: list[str], optional

    """
    timestamp_column: str
    prediction_length: int | None = ...
    id_columns: list[str] | None = ...
    freq: str | None = ...
    target_columns: list[str] | None = ...
    observable_columns: list[str] | None = ...
    control_columns: list[str] | None = ...
    conditional_columns: list[str] | None = ...
    static_categorical_columns: list[str] | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for TSForecastParameters."""
        ...
    


@dataclass
class PeftParameters(BaseSchema):
    type: str
    rank: int | None = ...
    target_modules: list | None = ...
    lora_alpha: int | None = ...
    lora_dropout: float | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for PeftParameters."""
        ...
    


@dataclass
class AutoAIRAGModelParams(BaseSchema):
    """
    **Deprecated parameters:**
        - ``decoding_method``
        - ``min_new_tokens``
        - ``max_new_tokens``
        - ``max_sequence_length``
    """
    decoding_method: str | TextGenDecodingMethod | None = ...
    min_new_tokens: int | None = ...
    max_new_tokens: int | None = ...
    max_sequence_length: int | None = ...
    max_completion_tokens: int | None = ...
    temperature: float | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for AutoAIRAGModelParams."""
        ...
    


@dataclass
class AutoAIRAGChatTemplateMessagesConfig(BaseSchema):
    system_message_text: str
    user_message_text: str
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for AutoAIRAGChatTemplateMessagesConfig."""
        ...
    


@dataclass
class AutoAIRAGModelConfig(BaseSchema):
    """
    **Deprecated parameters:**
        - ``prompt_template_text``
    """
    model_id: str
    parameters: dict | AutoAIRAGModelParams | None = ...
    chat_template_messages: dict | AutoAIRAGChatTemplateMessagesConfig | None = ...
    prompt_template_text: str | None = ...
    context_template_text: str | None = ...
    word_to_token_ratio: float | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for AutoAIRAGModelConfig."""
        ...
    


@dataclass
class AutoAIRAGCustomModelConfig(BaseSchema):
    """
    **Deprecated parameters:**
        - ``prompt_template_text``
    """
    deployment_id: str
    space_id: str | None = ...
    project_id: str | None = ...
    parameters: dict | AutoAIRAGModelParams | None = ...
    chat_template_messages: dict | AutoAIRAGChatTemplateMessagesConfig | None = ...
    prompt_template_text: str | None = ...
    context_template_text: str | None = ...
    word_to_token_ratio: float | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for AutoAIRAGCustomModelConfig."""
        ...
    


class HybridRankerStrategy(StrEnum):
    WEIGHTED = ...
    RRF = ...


@dataclass
class AutoAIRAGHybridRankerParams(BaseSchema):
    strategy: str | HybridRankerStrategy
    sparse_vectors: dict[str, str] | None = ...
    alpha: float | None = ...
    k: int | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for AutoAIRAGHybridRankerParams."""
        ...
    


@dataclass
class AutoAIRAGRetrievalConfig(BaseSchema):
    method: str | RetrievalMethod
    number_of_chunks: int | None = ...
    window_size: int | None = ...
    hybrid_ranker: dict | AutoAIRAGHybridRankerParams | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for AutoAIRAGRetrievalConfig."""
        ...
    


@dataclass
class AutoAIRAGLanguageConfig(BaseSchema):
    auto_detect: bool | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for AutoAIRAGLanguageConfig."""
        ...
    


@dataclass
class AutoAIRAGGenerationConfig(BaseSchema):
    language: dict | AutoAIRAGLanguageConfig | None = ...
    foundation_models: (list[dict | AutoAIRAGModelConfig | AutoAIRAGCustomModelConfig] | None) = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for AutoAIRAGGenerationConfig."""
        ...
    


@dataclass
class AutoAIRAGDeploymentConfig(BaseSchema):
    @dataclass
    class Service(BaseSchema):
        space_id: str
        auto_deploy: bool | None = ...
    
    
    inference_service: Service | None = ...
    indexing_service: Service | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for AutoAIRAGGenerationConfig."""
        ...
    


@dataclass
class GuardianDetectors(BaseSchema):
    hap: dict | None = ...
    pii: dict | None = ...
    granite_guardian: dict | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for GuardianDetectors."""
        ...
    


class SchemasMergeStrategy(StrEnum):
    """Strategy for schemas merge."""
    MERGE = ...
    REPLACE = ...


class OCRMode(StrEnum):
    DISABLED = ...
    ENABLED = ...
    FORCED = ...


class ClassificationMode(StrEnum):
    EXACT = ...
    BINARY = ...


@dataclass
class TextClassificationSemanticConfig(BaseSchema):
    """Semantic configuration for text classification.

    :param schemas_merge_strategy: strategy for schemas merge
    :type schemas_merge_strategy: SchemasMergeStrategy, optional

    :param schemas: schemas
    :type schemas: list[dict], optional
    """
    schemas_merge_strategy: SchemasMergeStrategy | None = ...
    schemas: list[dict] | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for TextClassificationSemanticConfig."""
        ...
    


@dataclass
class TextClassificationParameters(BaseSchema):
    """Parameters used for text classification.

    :param ocr_mode: whether OCR should be used when processing a document, an empty value allows the service
                     to select the best option for your processing mode
    :type ocr_mode: OCRMode, optional

    :param classification_mode: classification mode, the value exact gives the exact schema name the document
                                is classified to, the option `binary` only gives whether the document is classified
                                to a known schema or not
    :type classification_mode: ClassificationMode, optional

    :param auto_rotation_correction: whether should the service attempt to fix a rotated page or image
    :type auto_rotation_correction: bool, optional

    :param languages: set of languages to be expected in the document, the language codes follow ISO 639 where possible,
                      see the REST API documentation for the currently supported languages
    :type languages: list[str], optional

    :param semantic_config: additional configuration settings for the Semantic KVP model
    :type semantic_config: TextClassificationSemanticConfig, optional
    """
    ocr_mode: OCRMode | None = ...
    classification_mode: ClassificationMode | None = ...
    auto_rotation_correction: bool | None = ...
    languages: list[str] | None = ...
    semantic_config: TextClassificationSemanticConfig | None = ...
    @classmethod
    def get_sample_params(cls) -> dict[str, Any]:
        """Provide example values for TextClassificationParameters."""
        ...
    


