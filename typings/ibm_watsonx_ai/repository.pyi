"""
This type stub file was generated by pyright.
"""

import numpy
import pandas
import pyspark.sql
from dataclasses import dataclass
from pathlib import Path
from typing import Any, AsyncGenerator, Callable, Generator, Literal, TYPE_CHECKING, TypeAlias
from ibm_watsonx_ai.ai_services import AIServices
from ibm_watsonx_ai.experiments import Experiments
from ibm_watsonx_ai.functions import Functions
from ibm_watsonx_ai.lifecycle import SpecStates
from ibm_watsonx_ai.models import Models
from ibm_watsonx_ai.pipelines import Pipelines
from ibm_watsonx_ai.utils import inherited_docstring
from ibm_watsonx_ai.wml_resource import WMLResource
from ibm_watsonx_ai import APIClient

if TYPE_CHECKING:
    LabelColumnNamesType: TypeAlias = (numpy.ndarray[Any, numpy.dtype[numpy.str_]] | list[str])
    TrainingDataType: TypeAlias = (pandas.DataFrame | numpy.ndarray | pyspark.sql.DataFrame | list)
    TrainingTargetType: TypeAlias = (pandas.DataFrame | pandas.Series | numpy.ndarray | list)
    FeatureNamesArrayType: TypeAlias = numpy.ndarray | list
class Repository(WMLResource):
    """Store and manage models, functions, spaces, pipelines, and experiments
    using the Watson Machine Learning Repository.

    To view ModelMetaNames, use:

    .. code-block:: python

        client.repository.ModelMetaNames.show()

    To view ExperimentMetaNames, use:

    .. code-block:: python

        client.repository.ExperimentMetaNames.show()

    To view FunctionMetaNames, use:

    .. code-block:: python

        client.repository.FunctionMetaNames.show()

    To view PipelineMetaNames, use:

    .. code-block:: python

        client.repository.PipelineMetaNames.show()

    To view AIServiceMetaNames, use:

    .. code-block:: python

        client.repository.AIServiceMetaNames.show()

    """
    @dataclass
    class ModelAssetTypes:
        """Data class with supported model asset types."""
        DO_DOCPLEX_20_1: str = ...
        DO_OPL_20_1: str = ...
        DO_CPLEX_20_1: str = ...
        DO_CPO_20_1: str = ...
        DO_DOCPLEX_22_1: str = ...
        DO_OPL_22_1: str = ...
        DO_CPLEX_22_1: str = ...
        DO_CPO_22_1: str = ...
        WML_HYBRID_0_1: str = ...
        PMML_4_2_1: str = ...
        PYTORCH_ONNX_1_12: str = ...
        PYTORCH_ONNX_RT22_2: str = ...
        PYTORCH_ONNX_2_0: str = ...
        PYTORCH_ONNX_RT23_1: str = ...
        SCIKIT_LEARN_1_1: str = ...
        MLLIB_3_3: str = ...
        SPSS_MODELER_17_1: str = ...
        SPSS_MODELER_18_1: str = ...
        SPSS_MODELER_18_2: str = ...
        TENSORFLOW_2_9: str = ...
        TENSORFLOW_RT22_2: str = ...
        TENSORFLOW_2_12: str = ...
        TENSORFLOW_RT23_1: str = ...
        XGBOOST_1_6: str = ...
        PROMPT_TUNE_1_0: str = ...
        CUSTOM_FOUNDATION_MODEL_1_0: str = ...
        CURATED_FOUNDATION_MODEL_1_0: str = ...
        BASE_FOUNDATION_MODEL_1_0: str = ...
    
    
    cloud_platform_spaces = ...
    icp_platform_spaces = ...
    def __init__(self, client: APIClient) -> None:
        ...
    
    @inherited_docstring(Experiments.store, { "experiments.get_href": "repository.get_experiment_href" })
    def store_experiment(self, meta_props: dict) -> dict:
        ...
    
    @inherited_docstring(Experiments.astore, { "experiments.get_href": "repository.get_experiment_href" })
    async def astore_experiment(self, meta_props: dict) -> dict:
        ...
    
    @inherited_docstring(Pipelines.store)
    def store_pipeline(self, meta_props: dict) -> dict:
        ...
    
    @inherited_docstring(Pipelines.astore)
    async def astore_pipeline(self, meta_props: dict) -> dict:
        ...
    
    @inherited_docstring(Models.store, { "store()": "store_model()" })
    def store_model(self, model: str | object | None = ..., meta_props: dict | None = ..., training_data: TrainingDataType | None = ..., training_target: TrainingTargetType | None = ..., pipeline: object | None = ..., feature_names: FeatureNamesArrayType | None = ..., label_column_names: LabelColumnNamesType | None = ..., subtrainingId: str | None = ..., experiment_metadata: dict | None = ..., training_id: str | None = ...) -> dict:
        ...
    
    @inherited_docstring(Models.astore, { "astore()": "astore_model()" })
    async def astore_model(self, model: str | object | None = ..., meta_props: dict | None = ..., training_data: TrainingDataType | None = ..., training_target: TrainingTargetType | None = ..., pipeline: object | None = ..., feature_names: FeatureNamesArrayType | None = ..., label_column_names: LabelColumnNamesType | None = ..., subtrainingId: str | None = ..., experiment_metadata: dict | None = ..., training_id: str | None = ...) -> dict:
        ...
    
    def clone(self, artifact_id: str, space_id: str | None = ..., action: str = ..., rev_id: str | None = ...) -> dict:
        ...
    
    @inherited_docstring(Functions.store)
    def store_function(self, function: str | Callable, meta_props: str | dict[str, Any]) -> dict:
        ...
    
    @inherited_docstring(Functions.astore)
    async def astore_function(self, function: str | Callable, meta_props: str | dict[str, Any]) -> dict:
        ...
    
    @inherited_docstring(Models.create_revision)
    def create_model_revision(self, model_id: str | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Models.acreate_revision)
    async def acreate_model_revision(self, model_id: str) -> dict:
        ...
    
    @inherited_docstring(Pipelines.create_revision)
    def create_pipeline_revision(self, pipeline_id: str | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Pipelines.acreate_revision)
    async def acreate_pipeline_revision(self, pipeline_id: str) -> dict:
        ...
    
    @inherited_docstring(Functions.create_revision)
    def create_function_revision(self, function_id: str | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Functions.acreate_revision)
    async def acreate_function_revision(self, function_id: str) -> dict:
        ...
    
    @inherited_docstring(Experiments.create_revision)
    def create_experiment_revision(self, experiment_id: str) -> dict:
        ...
    
    @inherited_docstring(Experiments.acreate_revision)
    async def acreate_experiment_revision(self, experiment_id: str) -> dict:
        ...
    
    @inherited_docstring(Models.update, { "meta_props": "updated_meta_props" })
    def update_model(self, model_id: str | None = ..., updated_meta_props: dict | None = ..., update_model: Any | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Models.aupdate, { "meta_props": "updated_meta_props" })
    async def aupdate_model(self, model_id: str, updated_meta_props: dict | None = ..., update_model: Any | None = ...) -> dict:
        ...
    
    @inherited_docstring(Experiments.update)
    def update_experiment(self, experiment_id: str | None = ..., changes: dict | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Experiments.aupdate)
    async def aupdate_experiment(self, experiment_id: str, changes: dict) -> dict:
        ...
    
    @inherited_docstring(Functions.update)
    def update_function(self, function_id: str | None, changes: dict | None = ..., update_function: str | Callable | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Functions.aupdate)
    async def aupdate_function(self, function_id: str, changes: dict, update_function: str | Callable | None = ...) -> dict:
        ...
    
    @inherited_docstring(Pipelines.update)
    def update_pipeline(self, pipeline_id: str | None = ..., changes: dict | None = ..., rev_id: str | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Pipelines.aupdate)
    async def aupdate_pipeline(self, pipeline_id: str, changes: dict, rev_id: str | None = ...) -> dict:
        ...
    
    @inherited_docstring(Models.load, actual_type_override="model")
    def load(self, artifact_id: str | None = ..., **kwargs: Any) -> object:
        ...
    
    @inherited_docstring(Models.aload, actual_type_override="model")
    async def aload(self, artifact_id: str) -> object:
        ...
    
    def download(self, artifact_id: str | None = ..., filename: str | Path = ..., rev_id: str | None = ..., format: str | None = ..., **kwargs: Any) -> str:
        """Download the configuration file for an artifact with the specified ID.

        :param artifact_id: unique ID of the model or function
        :type artifact_id: str
        :param filename: name of the file to which the artifact content will be downloaded
        :type filename: str | Path, optional
        :param rev_id: revision ID
        :type rev_id: str, optional
        :param format: format of the content, applicable for models
        :type format: str, optional

        :return: path to the downloaded artifact content
        :rtype: str

        **Examples**

        .. code-block:: python

            client.repository.download(model_id, "my_model.tar.gz")
            client.repository.download(
                model_id, "my_model.json"
            )  # if original model was saved as json, works only for xgboost 1.3

        """
        ...
    
    async def adownload(self, artifact_id: str, filename: str | Path = ..., rev_id: str | None = ..., format: str | None = ...) -> str:
        """Download the configuration file for an artifact with the specified ID asynchronously.

        :param artifact_id: unique ID of the model or function
        :type artifact_id: str
        :param filename: name of the file to which the artifact content will be downloaded
        :type filename: str | Path, optional
        :param rev_id: revision ID
        :type rev_id: str, optional
        :param format: format of the content, applicable for models
        :type format: str, optional

        :return: path to the downloaded artifact content
        :rtype: str

        **Examples**

        .. code-block:: python

            await client.repository.adownload(model_id, "my_model.tar.gz")
            await client.repository.adownload(
                model_id, "my_model.json"
            )  # if original model was saved as json, works only for xgboost 1.3

        """
        ...
    
    def delete(self, artifact_id: str | None = ..., force: bool = ..., **kwargs: Any) -> Literal["SUCCESS"]:
        """Delete a model, experiment, pipeline, function, or AI service from the repository.

        :param artifact_id: unique ID of the stored model, experiment, function, pipeline, or AI service
        :type artifact_id: str

        :param force: if True, the delete operation will proceed even when the artifact deployment exists, defaults to False
        :type force: bool, optional

        :return: status "SUCCESS" if deletion is successful
        :rtype: Literal["SUCCESS"]
        :raises: ApiRequestFailure if deletion failed

        **Example:**

        .. code-block:: python

            client.repository.delete(artifact_id)

        """
        ...
    
    async def adelete(self, artifact_id: str, force: bool = ...) -> Literal["SUCCESS"]:
        """Delete a model, experiment, pipeline, function, or AI service from the repository asynchronously.

        :param artifact_id: unique ID of the stored model, experiment, function, pipeline, or AI service
        :type artifact_id: str

        :param force: if True, the delete operation will proceed even when the artifact deployment exists, defaults to False
        :type force: bool, optional

        :return: status "SUCCESS" if deletion is successful
        :rtype: Literal["SUCCESS"]
        :raises: ApiRequestFailure if deletion failed

        **Example:**

        .. code-block:: python

            await client.repository.adelete(artifact_id)

        """
        ...
    
    def get_details(self, artifact_id: str | None = ..., spec_state: SpecStates | None = ..., artifact_name: str | None = ..., **kwargs: Any) -> dict | Generator:
        """Get metadata of stored artifacts. If `artifact_id` and `artifact_name` are not specified,
        the metadata of all models, experiments, functions, pipelines, and ai services is returned.
        If only `artifact_name` is specified, metadata of all artifacts with the name is returned.

        :param artifact_id: unique ID of the stored model, experiment, function, or pipeline
        :type artifact_id: str, optional

        :param spec_state: software specification state, can be used only when `artifact_id` is None
        :type spec_state: SpecStates, optional

        :param artifact_name: name of the stored model, experiment, function, pipeline, or ai service
            can be used only when `artifact_id` is None
        :type artifact_name: str, optional

        :return: metadata of the stored artifact(s)
        :rtype:
            - dict (if artifact_id is not None)
            - {"models": dict, "experiments": dict, "pipeline": dict, "functions": dict, "ai_service": dict} (if artifact_id is None)

        **Examples**

        .. code-block:: python

            details = client.repository.get_details(artifact_id)
            details = client.repository.get_details(artifact_name="Sample_model")
            details = client.repository.get_details()


        Example of getting all repository assets with deprecated software specifications:

        .. code-block:: python

            from ibm_watsonx_ai.lifecycle import SpecStates

            details = client.repository.get_details(
                spec_state=SpecStates.DEPRECATED
            )

        """
        ...
    
    async def aget_details(self, artifact_id: str | None = ..., spec_state: SpecStates | None = ..., artifact_name: str | None = ...) -> dict | AsyncGenerator:
        """Get metadata of stored artifacts asynchronously. If `artifact_id` and `artifact_name` are not specified,
        the metadata of all models, experiments, functions, pipelines, and ai services is returned.
        If only `artifact_name` is specified, metadata of all artifacts with the name is returned.

        :param artifact_id: unique ID of the stored model, experiment, function, or pipeline
        :type artifact_id: str, optional

        :param spec_state: software specification state, can be used only when `artifact_id` is None
        :type spec_state: SpecStates, optional

        :param artifact_name: name of the stored model, experiment, function, pipeline, or ai service
            can be used only when `artifact_id` is None
        :type artifact_name: str, optional

        :return: metadata of the stored artifact(s)
        :rtype:
            - dict (if artifact_id is not None)
            - {"models": dict, "experiments": dict, "pipeline": dict, "functions": dict, "ai_service": dict} (if artifact_id is None)

        **Examples**

        .. code-block:: python

            details = await client.repository.aget_details(artifact_id)
            details = await client.repository.aget_details(
                artifact_name="Sample_model"
            )
            details = await client.repository.aget_details()


        Example of getting all repository assets with deprecated software specifications:

        .. code-block:: python

            from ibm_watsonx_ai.lifecycle import SpecStates

            details = await client.repository.aget_details(
                spec_state=SpecStates.DEPRECATED
            )

        """
        ...
    
    def get_id_by_name(self, artifact_name: str) -> str:
        """Get the ID of a stored artifact by name.

        :param artifact_name: name of the stored artifact
        :type artifact_name: str

        :return: ID of the stored artifact if exactly one with the 'artifact_name' exists. Otherwise, raise an error.
        :rtype: str

        **Example:**

        .. code-block:: python

            artifact_id = client.repository.get_id_by_name(artifact_name)

        """
        ...
    
    async def aget_id_by_name(self, artifact_name: str) -> str:
        """Get the ID of a stored artifact by name asynchronously.

        :param artifact_name: name of the stored artifact
        :type artifact_name: str

        :return: ID of the stored artifact if exactly one with the 'artifact_name' exists. Otherwise, raise an error.
        :rtype: str

        **Example:**

        .. code-block:: python

            artifact_id = await client.repository.aget_id_by_name(artifact_name)

        """
        ...
    
    @inherited_docstring(Models.get_details)
    def get_model_details(self, model_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., model_name: str | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Models.aget_details)
    async def aget_model_details(self, model_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., model_name: str | None = ...) -> dict | AsyncGenerator:
        ...
    
    @inherited_docstring(Models.get_revision_details)
    def get_model_revision_details(self, model_id: str | None = ..., rev_id: str | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Models.aget_revision_details)
    async def aget_model_revision_details(self, model_id: str, rev_id: str) -> dict:
        ...
    
    @inherited_docstring(Experiments.get_details)
    def get_experiment_details(self, experiment_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., experiment_name: str | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Experiments.aget_details)
    async def aget_experiment_details(self, experiment_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., experiment_name: str | None = ...) -> dict:
        ...
    
    @inherited_docstring(Experiments.get_revision_details)
    def get_experiment_revision_details(self, experiment_id: str, rev_id: str, **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Experiments.aget_revision_details)
    async def aget_experiment_revision_details(self, experiment_id: str, rev_id: str) -> dict:
        ...
    
    @inherited_docstring(Functions.get_details)
    def get_function_details(self, function_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., function_name: str | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Functions.aget_details)
    async def aget_function_details(self, function_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., function_name: str | None = ...) -> dict:
        ...
    
    @inherited_docstring(Functions.get_revision_details)
    def get_function_revision_details(self, function_id: str, rev_id: str, **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Functions.aget_revision_details)
    async def aget_function_revision_details(self, function_id: str, rev_id: str) -> dict:
        ...
    
    @inherited_docstring(Pipelines.get_details)
    def get_pipeline_details(self, pipeline_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., pipeline_name: str | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Pipelines.aget_details)
    async def aget_pipeline_details(self, pipeline_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., pipeline_name: str | None = ...) -> dict:
        ...
    
    @inherited_docstring(Pipelines.get_revision_details)
    def get_pipeline_revision_details(self, pipeline_id: str | None = ..., rev_id: str | None = ..., **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(Pipelines.aget_revision_details)
    async def aget_pipeline_revision_details(self, pipeline_id: str, rev_id: str) -> dict:
        ...
    
    @staticmethod
    @inherited_docstring(Models.get_href)
    def get_model_href(model_details: dict) -> str:
        ...
    
    @staticmethod
    @inherited_docstring(Models.get_id)
    def get_model_id(model_details: dict) -> str:
        ...
    
    @staticmethod
    @inherited_docstring(Experiments.get_id, { "experiments.get_details": "repository.get_experiment_details" })
    def get_experiment_id(experiment_details: dict) -> str:
        ...
    
    @staticmethod
    @inherited_docstring(Experiments.get_href, { "experiments.get_details": "repository.get_experiment_details" })
    def get_experiment_href(experiment_details: dict) -> str:
        ...
    
    @staticmethod
    @inherited_docstring(Functions.get_id)
    def get_function_id(function_details: dict) -> str:
        ...
    
    @staticmethod
    @inherited_docstring(Functions.get_href)
    def get_function_href(function_details: dict) -> str:
        ...
    
    @staticmethod
    @inherited_docstring(Pipelines.get_href, { "pipelines.get_details": "repository.get_pipeline_details" })
    def get_pipeline_href(pipeline_details: dict) -> str:
        ...
    
    @staticmethod
    @inherited_docstring(Pipelines.get_id)
    def get_pipeline_id(pipeline_details: dict) -> str:
        ...
    
    def list(self, framework_filter: str | None = ...) -> pandas.DataFrame:
        """Get and list stored models, pipelines, functions, experiments, and AI services in a table/DataFrame format.

        :param framework_filter: get only the frameworks with the desired names
        :type framework_filter: str, optional

        :return: DataFrame with listed names and IDs of stored models
        :rtype: pandas.DataFrame

        **Example:**

        .. code-block:: python

            client.repository.list()
            client.repository.list(framework_filter="prompt_tune")

        """
        ...
    
    @inherited_docstring(Models.list)
    def list_models(self, limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ...) -> pandas.DataFrame | Generator:
        ...
    
    @inherited_docstring(Experiments.list)
    def list_experiments(self, limit: int | None = ...) -> pandas.DataFrame:
        ...
    
    @inherited_docstring(Functions.list)
    def list_functions(self, limit: int | None = ...) -> pandas.DataFrame:
        ...
    
    @inherited_docstring(Pipelines.list)
    def list_pipelines(self, limit: int | None = ...) -> pandas.DataFrame:
        ...
    
    def create_revision(self, artifact_id: str | None = ..., **kwargs: Any) -> dict:
        """Create a revision for passed `artifact_id`.

        :param artifact_id: unique ID of a stored model, experiment, function, or pipelines
        :type artifact_id: str

        :return: artifact new revision metadata
        :rtype: dict

        .. deprecated:: 1.3.39
            Use methods corresponding to the artifact type, for example ``create_model_revision()``.

        **Example:**

        .. code-block:: python

            details = client.repository.create_revision(artifact_id)

        """
        ...
    
    @inherited_docstring(Models.list_revisions)
    def list_models_revisions(self, model_id: str | None = ..., limit: int | None = ..., **kwargs: Any) -> pandas.DataFrame:
        ...
    
    @inherited_docstring(Pipelines.list_revisions)
    def list_pipelines_revisions(self, pipeline_id: str | None = ..., limit: int | None = ..., **kwargs: Any) -> pandas.DataFrame:
        ...
    
    @inherited_docstring(Functions.list_revisions)
    def list_functions_revisions(self, function_id: str | None = ..., limit: int | None = ..., **kwargs: Any) -> pandas.DataFrame:
        ...
    
    @inherited_docstring(Experiments.list_revisions)
    def list_experiments_revisions(self, experiment_id: str | None = ..., limit: int | None = ..., **kwargs: Any) -> pandas.DataFrame:
        ...
    
    @inherited_docstring(Models.promote)
    def promote_model(self, model_id: str, source_project_id: str, target_space_id: str) -> str:
        ...
    
    @inherited_docstring(AIServices.store)
    def store_ai_service(self, ai_service: str | Callable, meta_props: dict[str, Any]) -> dict:
        ...
    
    @inherited_docstring(AIServices.astore)
    async def astore_ai_service(self, ai_service: str | Callable, meta_props: dict[str, Any]) -> dict:
        ...
    
    @inherited_docstring(AIServices.get_details)
    def get_ai_service_details(self, ai_service_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., ai_service_name: str | None = ..., **kwargs: Any) -> dict | Generator:
        ...
    
    @inherited_docstring(AIServices.aget_details)
    async def aget_ai_service_details(self, ai_service_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., ai_service_name: str | None = ...) -> dict | AsyncGenerator:
        ...
    
    @inherited_docstring(AIServices.update)
    def update_ai_service(self, ai_service_id: str, changes: dict, update_ai_service: str | Callable | None = ...) -> dict:
        ...
    
    @inherited_docstring(AIServices.aupdate)
    async def aupdate_ai_service(self, ai_service_id: str, changes: dict, update_ai_service: str | Callable | None = ...) -> dict:
        ...
    
    @staticmethod
    @inherited_docstring(AIServices.get_id)
    def get_ai_service_id(ai_service_details: dict) -> str:
        ...
    
    @inherited_docstring(AIServices.list)
    def list_ai_services(self, limit: int | None = ...) -> pandas.DataFrame:
        ...
    
    @inherited_docstring(AIServices.create_revision)
    def create_ai_service_revision(self, ai_service_id: str, **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(AIServices.acreate_revision)
    async def acreate_ai_service_revision(self, ai_service_id: str) -> dict:
        ...
    
    @inherited_docstring(AIServices.get_revision_details)
    def get_ai_service_revision_details(self, ai_service_id: str, rev_id: str, **kwargs: Any) -> dict:
        ...
    
    @inherited_docstring(AIServices.aget_revision_details)
    async def aget_ai_service_revision_details(self, ai_service_id: str, rev_id: str) -> dict:
        ...
    
    @inherited_docstring(AIServices.list_revisions)
    def list_ai_service_revisions(self, ai_service_id: str, limit: int | None = ...) -> pandas.DataFrame:
        ...
    


