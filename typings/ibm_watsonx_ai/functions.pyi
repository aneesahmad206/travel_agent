"""
This type stub file was generated by pyright.
"""

import pandas
from pathlib import Path
from typing import Any, Callable, Literal, TYPE_CHECKING
from ibm_watsonx_ai.wml_resource import WMLResource
from ibm_watsonx_ai import APIClient
from ibm_watsonx_ai.lifecycle import SpecStates

if TYPE_CHECKING:
    ...
class Functions(WMLResource):
    """Store and manage functions."""
    ConfigurationMetaNames = ...
    def __init__(self, client: APIClient) -> None:
        ...
    
    def store(self, function: str | Path | Callable, meta_props: str | dict[str, Any]) -> dict:
        """Create a function.

        As a 'function' may be used one of the following:
            - filepath to gz file
            - 'score' function reference, where the function is the function which will be deployed
            - generator function, which takes no argument or arguments which all have primitive python default values
              and as result return 'score' function

        :param function: path to file with archived function content or function (as described above)
        :type function: str | Path | Callable
        :param meta_props: meta data or name of the function, to see available meta names
            use ``client._functions.ConfigurationMetaNames.show()``
        :type meta_props: str or dict

        :return: stored function metadata
        :rtype: dict

        **Examples**

        The most simple use is (using `score` function):

        .. code-block:: python

            meta_props = {
                client._functions.ConfigurationMetaNames.NAME: "function",
                client._functions.ConfigurationMetaNames.DESCRIPTION: "This is ai function",
                client._functions.ConfigurationMetaNames.SOFTWARE_SPEC_UID: "53dc4cf1-252f-424b-b52d-5cdd9814987f",
            }


            def score(payload):
                values = [[row[0] * row[1]] for row in payload["values"]]
                return {"fields": ["multiplication"], "values": values}


            stored_function_details = client._functions.store(score, meta_props)

        Other, more interesting example is using generator function.
        In this situation it is possible to pass some variables:

        .. code-block:: python

            creds = {...}


            def gen_function(credentials=creds, x=2):
                def f(payload):
                    values = [[row[0] * row[1] * x] for row in payload["values"]]
                    return {"fields": ["multiplication"], "values": values}

                return f


            stored_function_details = client._functions.store(
                gen_function, meta_props
            )

        """
        ...
    
    async def astore(self, function: str | Path | Callable, meta_props: str | dict[str, Any]) -> dict:
        """Create a function asynchronously.

        As a 'function' may be used one of the following:
            - filepath to gz file
            - 'score' function reference, where the function is the function which will be deployed
            - generator function, which takes no argument or arguments which all have primitive python default values
              and as result return 'score' function

        :param function: path to file with archived function content or function (as described above)
        :type function: str | Path | Callable
        :param meta_props: meta data or name of the function, to see available meta names
            use ``client._functions.ConfigurationMetaNames.show()``
        :type meta_props: str or dict

        :return: stored function metadata
        :rtype: dict

        **Examples**

        The most simple use is (using `score` function):

        .. code-block:: python

            meta_props = {
                client._functions.ConfigurationMetaNames.NAME: "function",
                client._functions.ConfigurationMetaNames.DESCRIPTION: "This is ai function",
                client._functions.ConfigurationMetaNames.SOFTWARE_SPEC_UID: "53dc4cf1-252f-424b-b52d-5cdd9814987f",
            }


            def score(payload):
                values = [[row[0] * row[1]] for row in payload["values"]]
                return {"fields": ["multiplication"], "values": values}


            stored_function_details = await client._functions.astore(
                score, meta_props
            )

        Other, more interesting example is using generator function.
        In this situation it is possible to pass some variables:

        .. code-block:: python

            creds = {...}


            def gen_function(credentials=creds, x=2):
                def f(payload):
                    values = [[row[0] * row[1] * x] for row in payload["values"]]
                    return {"fields": ["multiplication"], "values": values}

                return f


            stored_function_details = await client._functions.astore(
                gen_function, meta_props
            )

        """
        ...
    
    def update(self, function_id: str | None = ..., changes: dict | None = ..., update_function: str | Path | Callable | None = ..., **kwargs) -> dict:
        """Updates existing function metadata.

        :param function_id: ID of function which define what should be updated
        :type function_id: str
        :param changes: elements which should be changed, where keys are ConfigurationMetaNames
        :type changes: dict
        :param update_function: path to file with archived function content or function which should be changed
            for specific function_id, this parameter is valid only for CP4D 3.0.0
        :type update_function: str | Path | Callable, optional

        **Example:**

        .. code-block:: python

            metadata = {
                client._functions.ConfigurationMetaNames.NAME: "updated_function"
            }

            function_details = client._functions.update(
                function_id, changes=metadata
            )

        """
        ...
    
    async def aupdate(self, function_id: str, changes: dict, update_function: str | Path | Callable | None = ...) -> dict:
        """Updates existing function metadata asynchronously.

        :param function_id: ID of function which define what should be updated
        :type function_id: str
        :param changes: elements which should be changed, where keys are ConfigurationMetaNames
        :type changes: dict
        :param update_function: path to file with archived function content or function which should be changed
            for specific function_id, this parameter is valid only for CP4D 3.0.0
        :type update_function: str | Path | Callable, optional

        **Example:**

        .. code-block:: python

            metadata = {
                client._functions.ConfigurationMetaNames.NAME: "updated_function"
            }

            function_details = await client._functions.aupdate(
                function_id, changes=metadata
            )

        """
        ...
    
    def download(self, function_id: str | None = ..., filename: str | Path = ..., rev_id: str | None = ..., **kwargs) -> str:
        """Download function content from watsonx.ai repository to local file.

        :param function_id: stored function ID
        :type function: str

        :param filename: name of local file to create, example: function_content.gz
        :type filename: str | Path, optional

        :return: path to the downloaded function content
        :rtype: str

        **Example:**

        .. code-block:: python

            client._functions.download(function_id, "my_func.tar.gz")

        """
        ...
    
    async def adownload(self, function_id: str, filename: str | Path = ..., rev_id: str | None = ...) -> str:
        """Download function content from watsonx.ai repository to local file asynchronously.

        :param function_id: stored function ID
        :type function: str

        :param filename: name of local file to create, example: function_content.gz
        :type filename: str | Path, optional

        :return: path to the downloaded function content
        :rtype: str

        **Example:**

        .. code-block:: python

            await client._functions.adownload(function_id, "my_func.tar.gz")

        """
        ...
    
    def delete(self, function_id: str | None = ..., force: bool = ..., **kwargs) -> Literal["SUCCESS"]:
        """Delete a stored function.

        :param function_id: stored function ID
        :type function_id: str

        :param force: if True, the delete operation will proceed even when the function deployment exists, defaults to False
        :type force: bool, optional

        :return: status "SUCCESS" if deletion is successful
        :rtype: Literal["SUCCESS"]
        :raises: ApiRequestFailure if deletion failed

        **Example:**

        .. code-block:: python

            client._functions.delete(function_id)
        """
        ...
    
    async def adelete(self, function_id: str, force: bool = ...) -> Literal["SUCCESS"]:
        """Delete a stored function asynchronously.

        :param function_id: stored function ID
        :type function_id: str

        :param force: if True, the delete operation will proceed even when the function deployment exists, defaults to False
        :type force: bool, optional

        :return: status "SUCCESS" if deletion is successful
        :rtype: Literal["SUCCESS"]
        :raises: ApiRequestFailure if deletion failed

        **Example:**

        .. code-block:: python

            await client._functions.adelete(function_id)
        """
        ...
    
    def get_details(self, function_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., function_name: str | None = ..., **kwargs) -> dict:
        """Get metadata of function(s). If neither function ID nor function name is specified,
        the metadata of all functions is returned.
        If only function name is specified, metadata of functions with the name is returned (if any).

        :param function_id: ID of the function
        :type: str, optional

        :param limit: limit number of fetched records
        :type limit: int, optional

        :param asynchronous: if `True`, it will work as a generator
        :type asynchronous: bool, optional

        :param get_all: if `True`, it will get all entries in 'limited' chunks
        :type get_all: bool, optional

        :param spec_state: software specification state, can be used only when `function_id` is None
        :type spec_state: SpecStates, optional

        :param function_name: name of the function, can be used only when `function_id` is None
        :type function_name: str, optional

        :return: metadata of the function
        :rtype: dict (if ID is not None) or {"resources": [dict]} (if ID is None)

        .. note::
            In current implementation setting `spec_state=True` may break set `limit`,
            returning less records than stated by set `limit`.

        **Examples**

        .. code-block:: python

            function_details = client._functions.get_details(function_id)
            function_details = client._functions.get_details(
                function_name="Sample_function"
            )
            function_details = client._functions.get_details()
            function_details = client._functions.get_details(limit=100)
            function_details = client._functions.get_details(
                limit=100, get_all=True
            )
            function_details = []
            for entry in client._functions.get_details(
                limit=100, asynchronous=True, get_all=True
            ):
                function_details.extend(entry)

        """
        ...
    
    async def aget_details(self, function_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., function_name: str | None = ...) -> dict:
        """Get metadata of function(s) asynchronously. If neither function ID nor function name is specified,
        the metadata of all functions is returned.
        If only function name is specified, metadata of functions with the name is returned (if any).

        :param function_id: ID of the function
        :type: str, optional

        :param limit: limit number of fetched records
        :type limit: int, optional

        :param asynchronous: if `True`, it will work as a generator
        :type asynchronous: bool, optional

        :param get_all: if `True`, it will get all entries in 'limited' chunks
        :type get_all: bool, optional

        :param spec_state: software specification state, can be used only when `function_id` is None
        :type spec_state: SpecStates, optional

        :param function_name: name of the function, can be used only when `function_id` is None
        :type function_name: str, optional

        :return: metadata of the function
        :rtype: dict (if ID is not None) or {"resources": [dict]} (if ID is None)

        .. note::
            In current implementation setting `spec_state=True` may break set `limit`,
            returning less records than stated by set `limit`.

        **Examples**

        .. code-block:: python

            function_details = await client._functions.aget_details(function_id)
            function_details = await client._functions.aget_details(
                function_name="Sample_function"
            )
            function_details = await client._functions.aget_details()
            function_details = await client._functions.aget_details(limit=100)
            function_details = await client._functions.aget_details(
                limit=100, get_all=True
            )
            function_details = []
            async for entry in await client._functions.aget_details(
                limit=100, asynchronous=True, get_all=True
            ):
                function_details.extend(entry)

        """
        ...
    
    @classmethod
    def get_id(cls, function_details: dict) -> str:
        """Get ID of stored function.

        :param function_details: metadata of the stored function
        :type function_details: dict

        :return: ID of stored function
        :rtype: str

        **Example:**

        .. code-block:: python

            function_details = client.repository.get_function_details(function_id)
            function_id = client._functions.get_id(function_details)
        """
        ...
    
    @classmethod
    def get_uid(cls, function_details: dict) -> str:
        """Get UID of stored function.

        *Deprecated:* Use get_id(function_details) instead.

        :param function_details: metadata of the stored function
        :type function_details: dict

        :return: UID of stored function
        :rtype: str

        **Example:**

        .. code-block:: python

            function_details = client.repository.get_function_details(function_uid)
            function_uid = client._functions.get_uid(function_details)
        """
        ...
    
    @classmethod
    def get_href(cls, function_details: dict) -> str:
        """Get the URL of a stored function.

        :param function_details: details of the stored function
        :type function_details: dict

        :return: href of the stored function
        :rtype: str

        **Example:**

        .. code-block:: python

            function_details = client.repository.get_function_details(function_id)
            function_url = client._functions.get_href(function_details)
        """
        ...
    
    def list(self, limit: int | None = ...) -> pandas.DataFrame:
        """Return stored functions in a table format.

        :param limit: limit number of fetched records
        :type limit: int, optional

        :return: pandas.DataFrame with listed functions
        :rtype: pandas.DataFrame

        **Example:**

        .. code-block:: python

            client._functions.list()
        """
        ...
    
    def clone(self, function_id: str | None = ..., space_id: str | None = ..., action: str = ..., rev_id: str | None = ..., **kwargs) -> None:
        ...
    
    def create_revision(self, function_id: str | None = ..., **kwargs) -> dict:
        """Create a new function revision.

        :param function_id: unique ID of the function
        :type function_id: str

        :return: revised metadata of the stored function
        :rtype: dict

        **Example:**

        .. code-block:: python

            client._functions.create_revision(function_id)
        """
        ...
    
    async def acreate_revision(self, function_id: str) -> dict:
        """Create a new function revision asynchronously.

        :param function_id: unique ID of the function
        :type function_id: str

        :return: revised metadata of the stored function
        :rtype: dict

        **Example:**

        .. code-block:: python

            await client._functions.acreate_revision(function_id)
        """
        ...
    
    def get_revision_details(self, function_id: str, rev_id: str, **kwargs) -> dict:
        """Get metadata of a specific revision of a stored function.

        :param function_id: definition of the stored function
        :type function_id: str

        :param rev_id: unique ID of the function revision
        :type rev_id: str

        :return: stored function revision metadata
        :rtype: dict

        **Example:**

        .. code-block:: python

            function_revision_details = client._functions.get_revision_details(
                function_id, rev_id
            )

        """
        ...
    
    async def aget_revision_details(self, function_id: str, rev_id: str) -> dict:
        """Get metadata of a specific revision of a stored function asynchronously.

        :param function_id: definition of the stored function
        :type function_id: str

        :param rev_id: unique ID of the function revision
        :type rev_id: str

        :return: stored function revision metadata
        :rtype: dict

        **Example:**

        .. code-block:: python

            function_revision_details = (
                await client._functions.aget_revision_details(function_id, rev_id)
            )

        """
        ...
    
    def list_revisions(self, function_id: str | None = ..., limit: int | None = ..., **kwargs) -> pandas.DataFrame:
        """Print all revisions for a given function ID in a table format.

        :param function_id: unique ID of the stored function
        :type function_id: str

        :param limit: limit number of fetched records
        :type limit: int, optional

        :return: pandas.DataFrame with listed revisions
        :rtype: pandas.DataFrame

        **Example:**

        .. code-block:: python

            client._functions.list_revisions(function_id)

        """
        ...
    


