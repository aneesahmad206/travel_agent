"""
This type stub file was generated by pyright.
"""

import numpy
import pandas
import pyspark.sql
from pathlib import Path
from typing import Any, AsyncGenerator, Generator, TYPE_CHECKING, TypeAlias, overload
from ibm_watsonx_ai.metanames import LibraryMetaNames
from ibm_watsonx_ai.wml_resource import WMLResource
from ibm_watsonx_ai import APIClient
from ibm_watsonx_ai.sw_spec import SpecStates

if TYPE_CHECKING:
    LabelColumnNamesType: TypeAlias = (numpy.ndarray[Any, numpy.dtype[numpy.str_]] | list[str])
    TrainingDataType: TypeAlias = (pandas.DataFrame | numpy.ndarray | pyspark.sql.DataFrame | list)
    TrainingTargetType: TypeAlias = (pandas.DataFrame | pandas.Series | numpy.ndarray | list)
    FeatureNamesArrayType: TypeAlias = numpy.ndarray | list
PipelineType: TypeAlias = Any
MLModelType: TypeAlias = Any
class Models(WMLResource):
    """Store and manage models."""
    ConfigurationMetaNames = ...
    LibraryMetaNames = ...
    def __init__(self, client: APIClient) -> None:
        ...
    
    def store(self, model: MLModelType | Path = ..., meta_props: dict[str, Any] | None = ..., training_data: TrainingDataType | None = ..., training_target: TrainingTargetType | None = ..., pipeline: PipelineType | None = ..., version: bool = ..., artifactid: str | None = ..., feature_names: (numpy.ndarray[Any, numpy.dtype[numpy.str_]] | list[str] | None) = ..., label_column_names: LabelColumnNamesType | None = ..., subtrainingId: str | None = ..., experiment_metadata: dict[str, Any] | None = ..., training_id: str | None = ...) -> dict[str, Any]:
        """Create a model.

        :ref:`Here<save_models>` you can explore how to save external models in correct format.

        :param model: Can be one of following:

            - The train model object:\n
                - scikit-learn
                - xgboost
                - spark (PipelineModel)
            - path to saved model in format:\n
                - tensorflow / keras (.tar.gz)
                - pmml (.xml)
                - scikit-learn (.tar.gz)
                - spss (.str)
                - spark (.tar.gz)
                - xgboost (.tar.gz)
            - directory containing model file(s):\n
                - scikit-learn
                - xgboost
                - tensorflow
            - unique ID of the trained model
            - LLM name
        :type model: str (for filename, path, or LLM name) or object (corresponding to model type)

        :param meta_props: metadata of the models configuration. To see available meta names, use:

            .. code-block:: python

                client._models.ConfigurationMetaNames.get()

        :type meta_props: dict, optional

        :param training_data: Spark DataFrame supported for spark models. Pandas dataframe, numpy.ndarray or array
            supported for scikit-learn models
        :type training_data: spark dataframe, pandas dataframe, numpy.ndarray or array, optional

        :param training_target: array with labels required for scikit-learn models
        :type training_target: array, optional

        :param pipeline: pipeline required for spark mllib models
        :type pipeline: object, optional

        :param feature_names: feature names for the training data in case of Scikit-Learn/XGBoost models,
            this is applicable only in the case where the training data is not of type - pandas.DataFrame
        :type feature_names: numpy.ndarray or list, optional

        :param label_column_names: label column names of the trained Scikit-Learn/XGBoost models
        :type label_column_names: numpy.ndarray or list, optional

        :param experiment_metadata: metadata retrieved from the experiment that created the model
        :type experiment_metadata: dict, optional

        :param training_id: Run id of AutoAI or TuneExperiment experiment.
        :type training_id: str, optional

        :return: metadata of the created model
        :rtype: dict

        .. note::

            * For a keras model, model content is expected to contain a .h5 file and an archived version of it.

            * `feature_names` is an optional argument containing the feature names for the training data
              in case of Scikit-Learn/XGBoost models. Valid types are numpy.ndarray and list.
              This is applicable only in the case where the training data is not of type - pandas.DataFrame.

            * If the `training_data` is of type pandas.DataFrame and `feature_names` are provided,
              `feature_names` are ignored.

            * For INPUT_DATA_SCHEMA meta prop use list even when passing single input data schema. You can provide
              multiple schemas as dictionaries inside a list.

            * More details about Foundation Models you can find :ref:`here<foundation_models>`.

        **Examples**

        .. code-block:: python

            stored_model_details = client._models.store(model, name)

        In more complicated cases you should create proper metadata, similar to this one:

        .. code-block:: python

            sw_spec_id = client.software_specifications.get_id_by_name(
                "scikit-learn_0.23-py3.7"
            )

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "customer satisfaction prediction model",
                client._models.ConfigurationMetaNames.SOFTWARE_SPEC_ID: sw_spec_id,
                client._models.ConfigurationMetaNames.TYPE: "scikit-learn_0.23",
            }

        In case when you want to provide input data schema of the model, you can provide it as part of meta:

        .. code-block:: python

            sw_spec_id = client.software_specifications.get_id_by_name(
                "spss-modeler_18.1"
            )

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "customer satisfaction prediction model",
                client._models.ConfigurationMetaNames.SOFTWARE_SPEC_ID: sw_spec_id,
                client._models.ConfigurationMetaNames.TYPE: "spss-modeler_18.1",
                client._models.ConfigurationMetaNames.INPUT_DATA_SCHEMA: [
                    {
                        "id": "test",
                        "type": "list",
                        "fields": [
                            {"name": "age", "type": "float"},
                            {"name": "sex", "type": "float"},
                            {"name": "fbs", "type": "float"},
                            {"name": "restbp", "type": "float"},
                        ],
                    },
                    {
                        "id": "test2",
                        "type": "list",
                        "fields": [
                            {"name": "age", "type": "float"},
                            {"name": "sex", "type": "float"},
                            {"name": "fbs", "type": "float"},
                            {"name": "restbp", "type": "float"},
                        ],
                    },
                ],
            }

        ``store()`` method used with a local tar.gz file that contains a model:

        .. code-block:: python

            stored_model_details = client._models.store(
                path_to_tar_gz, meta_props=metadata, training_data=None
            )

        ``store()`` method used with a local directory that contains model files:

        .. code-block:: python

            stored_model_details = client._models.store(
                path_to_model_directory, meta_props=metadata, training_data=None
            )

        ``store()`` method used with the ID of a trained model:

        .. code-block:: python

            stored_model_details = client._models.store(
                trained_model_id, meta_props=metadata, training_data=None
            )

        ``store()`` method used with a pipeline that was generated by an AutoAI experiment:

        .. code-block:: python

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "AutoAI prediction model stored from object"
            }
            stored_model_details = client._models.store(
                pipeline_model,
                meta_props=metadata,
                experiment_metadata=experiment_metadata,
            )

        .. code-block:: python

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "AutoAI prediction Pipeline_1 model"
            }
            stored_model_details = client._models.store(
                model="Pipeline_1", meta_props=metadata, training_id=training_id
            )

        Example of storing a prompt tuned model:

        .. code-block:: python

            stored_model_details = client._models.store(
                training_id=prompt_tuning_run_id
            )

        Example of storing a custom foundation model:

        .. code-block:: python

            sw_spec_id = client.software_specifications.get_id_by_name(
                "watsonx-cfm-caikit-1.0"
            )

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "custom FM asset",
                client._models.ConfigurationMetaNames.SOFTWARE_SPEC_ID: sw_spec_id,
                client._models.ConfigurationMetaNames.TYPE: client.repository.ModelAssetTypes.CUSTOM_FOUNDATION_MODEL_1_0,
            }
            stored_model_details = client._models.store(
                model="mistralai/Mistral-7B-Instruct-v0.2", meta_props=metadata
            )

        Example of storing a base foundation model:

        .. code-block:: python

            sw_spec_id = client.software_specifications.get_id_by_name(
                "watsonx-cfm-caikit-1.0"
            )

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "Base FM asset",
                client._models.ConfigurationMetaNames.SOFTWARE_SPEC_ID: sw_spec_id,
                client._models.ConfigurationMetaNames.TYPE: client.repository.ModelAssetTypes.BASE_FOUNDATION_MODEL_1_0,
            }
            stored_model_details = client._models.store(
                model="ibm/granite-3-1-8b-base", meta_props=metadata
            )

        Example of storing a custom foundation model with defined functions:

        .. code-block:: python

            sw_spec_id = client.software_specifications.get_id_by_name(
                "watsonx-cfm-caikit-1.1"
            )

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "custom FM asset",
                client._models.ConfigurationMetaNames.SOFTWARE_SPEC_ID: sw_spec_id,
                client._models.ConfigurationMetaNames.TYPE: client.repository.ModelAssetTypes.CUSTOM_FOUNDATION_MODEL_1_0,
                client._models.ConfigurationMetaNames.FOUNDATION_MODEL: {
                    "functions": ["text_generation", "text_chat", "audio_chat"],
                },
                client._models.ConfigurationMetaNames.MODEL_LOCATION: {
                    "connection_id": "3e94ea31-3a62-4f4b-9a0e-c87ce9b633cd",
                    "bucket": "watsonx-byom-dnd",
                    "file_path": "ibm-granite-speech-3-3-8b",
                },
            }
            stored_model_details = client._models.store(
                model="", meta_props=metadata
            )

        """
        ...
    
    async def astore(self, model: MLModelType | Path = ..., meta_props: dict[str, Any] | None = ..., training_data: TrainingDataType | None = ..., training_target: TrainingTargetType | None = ..., pipeline: PipelineType | None = ..., version: bool = ..., artifactid: str | None = ..., feature_names: (numpy.ndarray[Any, numpy.dtype[numpy.str_]] | list[str] | None) = ..., label_column_names: LabelColumnNamesType | None = ..., subtrainingId: str | None = ..., experiment_metadata: dict[str, Any] | None = ..., training_id: str | None = ...) -> dict[str, Any]:
        """Create a model asynchronously.

        :ref:`Here<save_models>` you can explore how to save external models in correct format.

        :param model: Can be one of following:

            - The train model object:\n
                - scikit-learn
                - xgboost
                - spark (PipelineModel)
            - path to saved model in format:\n
                - tensorflow / keras (.tar.gz)
                - pmml (.xml)
                - scikit-learn (.tar.gz)
                - spss (.str)
                - spark (.tar.gz)
                - xgboost (.tar.gz)
            - directory containing model file(s):\n
                - scikit-learn
                - xgboost
                - tensorflow
            - unique ID of the trained model
            - LLM name
        :type model: str (for filename, path, or LLM name) or object (corresponding to model type)

        :param meta_props: metadata of the models configuration. To see available meta names, use:

            .. code-block:: python

                client._models.ConfigurationMetaNames.get()

        :type meta_props: dict, optional

        :param training_data: Spark DataFrame supported for spark models. Pandas dataframe, numpy.ndarray or array
            supported for scikit-learn models
        :type training_data: spark dataframe, pandas dataframe, numpy.ndarray or array, optional

        :param training_target: array with labels required for scikit-learn models
        :type training_target: array, optional

        :param pipeline: pipeline required for spark mllib models
        :type pipeline: object, optional

        :param feature_names: feature names for the training data in case of Scikit-Learn/XGBoost models,
            this is applicable only in the case where the training data is not of type - pandas.DataFrame
        :type feature_names: numpy.ndarray or list, optional

        :param label_column_names: label column names of the trained Scikit-Learn/XGBoost models
        :type label_column_names: numpy.ndarray or list, optional

        :param experiment_metadata: metadata retrieved from the experiment that created the model
        :type experiment_metadata: dict, optional

        :param training_id: Run id of AutoAI or TuneExperiment experiment.
        :type training_id: str, optional

        :return: metadata of the created model
        :rtype: dict

        .. note::

            * For a keras model, model content is expected to contain a .h5 file and an archived version of it.

            * `feature_names` is an optional argument containing the feature names for the training data
              in case of Scikit-Learn/XGBoost models. Valid types are numpy.ndarray and list.
              This is applicable only in the case where the training data is not of type - pandas.DataFrame.

            * If the `training_data` is of type pandas.DataFrame and `feature_names` are provided,
              `feature_names` are ignored.

            * For INPUT_DATA_SCHEMA meta prop use list even when passing single input data schema. You can provide
              multiple schemas as dictionaries inside a list.

            * More details about Foundation Models you can find :ref:`here<foundation_models>`.

        **Examples**

        .. code-block:: python

            stored_model_details = await client._models.astore(model, name)

        In more complicated cases you should create proper metadata, similar to this one:

        .. code-block:: python

            sw_spec_id = client.software_specifications.get_id_by_name(
                "scikit-learn_0.23-py3.7"
            )

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "customer satisfaction prediction model",
                client._models.ConfigurationMetaNames.SOFTWARE_SPEC_ID: sw_spec_id,
                client._models.ConfigurationMetaNames.TYPE: "scikit-learn_0.23",
            }

        In case when you want to provide input data schema of the model, you can provide it as part of meta:

        .. code-block:: python

            sw_spec_id = client.software_specifications.get_id_by_name(
                "spss-modeler_18.1"
            )

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "customer satisfaction prediction model",
                client._models.ConfigurationMetaNames.SOFTWARE_SPEC_ID: sw_spec_id,
                client._models.ConfigurationMetaNames.TYPE: "spss-modeler_18.1",
                client._models.ConfigurationMetaNames.INPUT_DATA_SCHEMA: [
                    {
                        "id": "test",
                        "type": "list",
                        "fields": [
                            {"name": "age", "type": "float"},
                            {"name": "sex", "type": "float"},
                            {"name": "fbs", "type": "float"},
                            {"name": "restbp", "type": "float"},
                        ],
                    },
                    {
                        "id": "test2",
                        "type": "list",
                        "fields": [
                            {"name": "age", "type": "float"},
                            {"name": "sex", "type": "float"},
                            {"name": "fbs", "type": "float"},
                            {"name": "restbp", "type": "float"},
                        ],
                    },
                ],
            }

        ``astore()`` method used with a local tar.gz file that contains a model:

        .. code-block:: python

            stored_model_details = await client._models.astore(
                path_to_tar_gz, meta_props=metadata, training_data=None
            )

        ``astore()`` method used with a local directory that contains model files:

        .. code-block:: python

            stored_model_details = await client._models.astore(
                path_to_model_directory, meta_props=metadata, training_data=None
            )

        ``astore()`` method used with the ID of a trained model:

        .. code-block:: python

            stored_model_details = await client._models.astore(
                trained_model_id, meta_props=metadata, training_data=None
            )

        ``astore()`` method used with a pipeline that was generated by an AutoAI experiment:

        .. code-block:: python

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "AutoAI prediction model stored from object"
            }
            stored_model_details = await client._models.astore(
                pipeline_model,
                meta_props=metadata,
                experiment_metadata=experiment_metadata,
            )

        .. code-block:: python

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "AutoAI prediction Pipeline_1 model"
            }
            stored_model_details = await client._models.astore(
                model="Pipeline_1", meta_props=metadata, training_id=training_id
            )

        Example of storing a prompt tuned model:

        .. code-block:: python

            stored_model_details = await client._models.astore(
                training_id=prompt_tuning_run_id
            )

        Example of storing a custom foundation model:

        .. code-block:: python

            sw_spec_id = client.software_specifications.get_id_by_name(
                "watsonx-cfm-caikit-1.0"
            )

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "custom FM asset",
                client._models.ConfigurationMetaNames.SOFTWARE_SPEC_ID: sw_spec_id,
                client._models.ConfigurationMetaNames.TYPE: client.repository.ModelAssetTypes.CUSTOM_FOUNDATION_MODEL_1_0,
            }
            stored_model_details = await client._models.astore(
                model="mistralai/Mistral-7B-Instruct-v0.2", meta_props=metadata
            )

        Example of storing a base foundation model:

        .. code-block:: python

            sw_spec_id = client.software_specifications.get_id_by_name(
                "watsonx-cfm-caikit-1.0"
            )

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "Base FM asset",
                client._models.ConfigurationMetaNames.SOFTWARE_SPEC_ID: sw_spec_id,
                client._models.ConfigurationMetaNames.TYPE: client.repository.ModelAssetTypes.BASE_FOUNDATION_MODEL_1_0,
            }
            stored_model_details = await client._models.astore(
                model="ibm/granite-3-1-8b-base", meta_props=metadata
            )

        Example of storing a custom foundation model with defined functions:

        .. code-block:: python

            sw_spec_id = client.software_specifications.get_id_by_name(
                "watsonx-cfm-caikit-1.1"
            )

            metadata = {
                client._models.ConfigurationMetaNames.NAME: "custom FM asset",
                client._models.ConfigurationMetaNames.SOFTWARE_SPEC_ID: sw_spec_id,
                client._models.ConfigurationMetaNames.TYPE: client.repository.ModelAssetTypes.CUSTOM_FOUNDATION_MODEL_1_0,
                client._models.ConfigurationMetaNames.FOUNDATION_MODEL: {
                    "functions": ["text_generation", "text_chat", "audio_chat"],
                },
                client._models.ConfigurationMetaNames.MODEL_LOCATION: {
                    "connection_id": "3e94ea31-3a62-4f4b-9a0e-c87ce9b633cd",
                    "bucket": "watsonx-byom-dnd",
                    "file_path": "ibm-granite-speech-3-3-8b",
                },
            }
            stored_model_details = await client._models.astore(
                model="", meta_props=metadata
            )

        """
        ...
    
    def update(self, model_id: str | None = ..., meta_props: dict | None = ..., update_model: MLModelType | Path = ..., **kwargs) -> dict[str, Any]:
        """Update an existing model.

        :param model_id: ID of model to be updated
        :type model_id: str

        :param meta_props: new set of meta_props to be updated
        :type meta_props: dict, optional

        :param update_model: archived model content file or path to directory that contains the archived model file
            that needs to be changed for the specific model_id
        :type update_model: object or model or Path, optional

        :return: updated metadata of the model
        :rtype: dict

        **Example:**

        .. code-block:: python

            model_details = client._models.update(
                model_id, update_model=updated_content
            )
        """
        ...
    
    async def aupdate(self, model_id: str, meta_props: dict | None = ..., update_model: MLModelType | Path = ...) -> dict[str, Any]:
        """Update an existing model asynchronously.

        :param model_id: ID of model to be updated
        :type model_id: str

        :param meta_props: new set of meta_props to be updated
        :type meta_props: dict, optional

        :param update_model: archived model content file or path to directory that contains the archived model file
            that needs to be changed for the specific model_id
        :type update_model: object or model or Path, optional

        :return: updated metadata of the model
        :rtype: dict

        **Example:**

        .. code-block:: python

            model_details = await client._models.aupdate(
                model_id, update_model=updated_content
            )
        """
        ...
    
    def load(self, artifact_id: str | None, **kwargs) -> Any:
        """Load a model from the repository to object in a local environment.

        .. note::
            The use of the load() method is restricted and not permitted for AutoAI models.

        :param artifact_id: ID of the stored model
        :type artifact_id: str

        :return: trained model
        :rtype: object

        **Example:**

        .. code-block:: python

            model = client._models.load(model_id)
        """
        ...
    
    async def aload(self, artifact_id: str) -> Any:
        """Load a model from the repository to object in a local environment asynchronously.

        :param artifact_id: ID of the stored model
        :type artifact_id: str

        :return: trained model
        :rtype: object

        **Example:**

        .. code-block:: python

            model = await client._models.aload(model_id)
        """
        ...
    
    def download(self, model_id: str | None, filename: str | Path = ..., rev_id: str | None = ..., format: str | None = ..., **kwargs) -> str:
        """Download a model from the repository to local file.

        :param model_id: ID of the stored model
        :type model_id: str

        :param filename: name of local file to be created
        :type filename: str | Path, optional

        :param rev_id: ID of the revision
        :type rev_id: str, optional

        :param format: format of the content
        :type format: str, optional

        **Example:**

        .. code-block:: python

            client._models.download(model_id, "my_model.tar.gz")
        """
        ...
    
    async def adownload(self, model_id: str, filename: str | Path = ..., rev_id: str | None = ..., format: str | None = ...) -> str:
        """Download a model from the repository to local file asynchronously.

        :param model_id: ID of the stored model
        :type model_id: str

        :param filename: name of local file to be created
        :type filename: str | Path, optional

        :param rev_id: ID of the revision
        :type rev_id: str, optional

        :param format: format of the content
        :type format: str, optional

        **Example:**

        .. code-block:: python

            await client._models.adownload(model_id, "my_model.tar.gz")
        """
        ...
    
    def delete(self, model_id: str | None = ..., force: bool = ..., **kwargs) -> dict[str, Any]:
        """Delete a model from the repository.

        :param model_id: ID of the stored model
        :type model_id: str

        :param force: if True, the delete operation will proceed even when the model deployment exists, defaults to False
        :type force: bool, optional

        **Example:**

        .. code-block:: python

            client._models.delete(model_id)
        """
        ...
    
    async def adelete(self, model_id: str, force: bool = ...) -> dict[str, Any]:
        """Delete a model from the repository asynchronously.

        :param model_id: ID of the stored model
        :type model_id: str

        :param force: if True, the delete operation will proceed even when the model deployment exists, defaults to False
        :type force: bool, optional

        **Example:**

        .. code-block:: python

            await client._models.adelete(model_id)
        """
        ...
    
    @overload
    def get_details(self, model_id: str = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., model_name: str | None = ..., **kwargs) -> dict[str, Any]:
        ...
    
    @overload
    def get_details(self, model_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., model_name: str | None = ..., **kwargs) -> dict[str, Any] | Generator:
        ...
    
    def get_details(self, model_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., model_name: str | None = ..., **kwargs) -> dict[str, Any] | Generator:
        """Get metadata of stored models. If neither model ID nor model name is specified,
        the metadata of all models is returned.
        If only model name is specified, metadata of models with the name is returned (if any).

        :param model_id: ID of the stored model, definition, or pipeline
        :type model_id: str, optional

        :param limit: limit number of fetched records
        :type limit: int, optional

        :param asynchronous: if `True`, it will work as a generator
        :type asynchronous: bool, optional

        :param get_all: if `True`, it will get all entries in 'limited' chunks
        :type get_all: bool, optional

        :param spec_state: software specification state, can be used only when `model_id` is None
        :type spec_state: SpecStates, optional

        :param model_name: name of the stored model, definition, or pipeline, can be used only when `model_id` is None
        :type model_name: str, optional

        :return: metadata of the stored model(s)
        :rtype: dict (if ID is not None) or {"resources": [dict]} (if ID is None)

        .. note::
            In current implementation setting `spec_state` may break set `limit`,
            returning less records than stated by set `limit`.

        **Example:**

        .. code-block:: python

            model_details = client._models.get_details(model_id)
            models_details = client._models.get_details(model_name="Sample_model")
            models_details = client._models.get_details()
            models_details = client._models.get_details(limit=100)
            models_details = client._models.get_details(limit=100, get_all=True)
            models_details = []
            for entry in client._models.get_details(
                limit=100, asynchronous=True, get_all=True
            ):
                models_details.extend(entry)

        """
        ...
    
    @overload
    async def aget_details(self, model_id: str = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., model_name: str | None = ...) -> dict[str, Any]:
        ...
    
    @overload
    async def aget_details(self, model_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., model_name: str | None = ...) -> dict[str, Any] | AsyncGenerator:
        ...
    
    async def aget_details(self, model_id: str | None = ..., limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ..., spec_state: SpecStates | None = ..., model_name: str | None = ...) -> dict[str, Any] | AsyncGenerator:
        """Get metadata of stored models asynchronously. If neither model ID nor model name is specified,
        the metadata of all models is returned.
        If only model name is specified, metadata of models with the name is returned (if any).

        :param model_id: ID of the stored model, definition, or pipeline
        :type model_id: str, optional

        :param limit: limit number of fetched records
        :type limit: int, optional

        :param asynchronous: if `True`, it will work as a generator
        :type asynchronous: bool, optional

        :param get_all: if `True`, it will get all entries in 'limited' chunks
        :type get_all: bool, optional

        :param spec_state: software specification state, can be used only when `model_id` is None
        :type spec_state: SpecStates, optional

        :param model_name: name of the stored model, definition, or pipeline, can be used only when `model_id` is None
        :type model_name: str, optional

        :return: metadata of the stored model(s)
        :rtype: dict (if ID is not None) or {"resources": [dict]} (if ID is None)

        .. note::
            In current implementation setting `spec_state` may break set `limit`,
            returning less records than stated by set `limit`.

        **Example:**

        .. code-block:: python

            model_details = await client._models.aget_details(model_id)
            models_details = await client._models.aget_details(
                model_name="Sample_model"
            )
            models_details = await client._models.aget_details()
            models_details = await client._models.aget_details(limit=100)
            models_details = await client._models.aget_details(
                limit=100, get_all=True
            )
            models_details = []
            async for entry in await client._models.aget_details(
                limit=100, asynchronous=True, get_all=True
            ):
                models_details.extend(entry)

        """
        ...
    
    @staticmethod
    def get_href(model_details: dict[str, Any]) -> str:
        """Get the URL of a stored model.

        :param model_details: details of the stored model
        :type model_details: dict

        :return: URL of the stored model
        :rtype: str

        **Example:**

        .. code-block:: python

            model_url = client._models.get_href(model_details)
        """
        ...
    
    @staticmethod
    def get_uid(model_details: dict[str, Any]) -> str:
        """Get the UID of a stored model.

        *Deprecated:* Use ``get_id(model_details)`` instead.

        :param model_details: details of the stored model
        :type model_details: dict

        :return: UID of the stored model
        :rtype: str

        **Example:**

        .. code-block:: python

            model_uid = client._models.get_uid(model_details)
        """
        ...
    
    @staticmethod
    def get_id(model_details: dict[str, Any]) -> str:
        """Get the ID of a stored model.

        :param model_details: details of the stored model
        :type model_details: dict

        :return: ID of the stored model
        :rtype: str

        **Example:**

        .. code-block:: python

            model_id = client._models.get_id(model_details)
        """
        ...
    
    def list(self, limit: int | None = ..., asynchronous: bool = ..., get_all: bool = ...) -> pandas.DataFrame | Generator:
        """List stored models in a table format.

        :param limit: limit number of fetched records
        :type limit: int, optional

        :param asynchronous: if `True`, it will work as a generator
        :type asynchronous: bool, optional

        :param get_all: if `True`, it will get all entries in 'limited' chunks
        :type get_all: bool, optional

        :return: pandas.DataFrame with listed models or generator if `asynchronous` is set to True
        :rtype: pandas.DataFrame | Generator

        **Example:**

        .. code-block:: python

            client._models.list()
            client._models.list(limit=100)
            client._models.list(limit=100, get_all=True)
            [
                entry
                for entry in client._models.list(
                    limit=100, asynchronous=True, get_all=True
                )
            ]
        """
        ...
    
    def create_revision(self, model_id: str | None = ..., **kwargs) -> dict[str, Any]:
        """Create a revision for a given model ID.

        :param model_id: ID of the stored model
        :type model_id: str

        :return: revised metadata of the stored model
        :rtype: dict

        **Example:**

        .. code-block:: python

            model_details = client._models.create_revision(model_id)
        """
        ...
    
    async def acreate_revision(self, model_id: str) -> dict[str, Any]:
        """Create a revision for a given model ID asynchronously.

        :param model_id: ID of the stored model
        :type model_id: str

        :return: revised metadata of the stored model
        :rtype: dict

        **Example:**

        .. code-block:: python

            model_details = await client._models.acreate_revision(model_id)
        """
        ...
    
    def list_revisions(self, model_id: str | None = ..., limit: int | None = ..., **kwargs) -> pandas.DataFrame:
        """Print all revisions for the given model ID in a table format.

        :param model_id: unique ID of the stored model
        :type model_id: str

        :param limit: limit number of fetched records
        :type limit: int, optional

        :return: pandas.DataFrame with listed revisions
        :rtype: pandas.DataFrame

        **Example:**

        .. code-block:: python

            client._models.list_revisions(model_id)
        """
        ...
    
    def get_revision_details(self, model_id: str | None = ..., rev_id: str | None = ..., **kwargs) -> dict[str, Any]:
        """Get metadata of a stored model's specific revision.

        :param model_id: ID of the stored model, definition, or pipeline
        :type model_id: str

        :param rev_id: unique ID of the stored model revision
        :type rev_id: str

        :return: metadata of the stored model(s)
        :rtype: dict

        **Example:**

        .. code-block:: python

            model_details = client._models.get_revision_details(model_id, rev_id)
        """
        ...
    
    async def aget_revision_details(self, model_id: str, rev_id: str) -> dict[str, Any]:
        """Get metadata of a stored model's specific revision asynchronously.

        :param model_id: ID of the stored model, definition, or pipeline
        :type model_id: str

        :param rev_id: unique ID of the stored model revision
        :type rev_id: str

        :return: metadata of the stored model(s)
        :rtype: dict

        **Example:**

        .. code-block:: python

            model_details = await client._models.aget_revision_details(
                model_id, rev_id
            )
        """
        ...
    
    def promote(self, model_id: str, source_project_id: str, target_space_id: str) -> dict[str, Any] | None:
        """Promote a model from a project to space. Supported only for IBM Cloud PakÂ® for Data.

        *Deprecated:* Use `client.spaces.promote(asset_id, source_project_id, target_space_id)` instead.
        """
        ...
    


