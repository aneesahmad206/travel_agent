"""
This type stub file was generated by pyright.
"""

from typing import Any, Literal, TYPE_CHECKING
from ibm_watsonx_ai.metanames import MemberMetaNames
from ibm_watsonx_ai.wml_resource import WMLResource
from pandas import DataFrame
from ibm_watsonx_ai import APIClient

if TYPE_CHECKING:
    ...
class Spaces(WMLResource):
    """Store and manage spaces."""
    ConfigurationMetaNames = ...
    MemberMetaNames = ...
    def __init__(self, client: APIClient) -> None:
        ...
    
    def store(self, meta_props: dict, background_mode: bool = ...) -> dict:
        """Create a space. The instance associated with the space via COMPUTE will be used for billing purposes on
        the cloud. Note that STORAGE and COMPUTE are applicable only for cloud.

        :param meta_props: metadata of the space configuration. To see available meta names, use:

            .. code-block:: python

                client.spaces.ConfigurationMetaNames.get()

        :type meta_props: dict

        :param background_mode: indicator if store() method will run in background (async) or (sync)
        :type background_mode: bool, optional

        :return: metadata of the stored space
        :rtype: dict

        **Example:**

        .. code-block:: python

            metadata = {
                client.spaces.ConfigurationMetaNames.NAME: "my_space",
                client.spaces.ConfigurationMetaNames.DESCRIPTION: "spaces",
                client.spaces.ConfigurationMetaNames.STORAGE: {
                    "resource_crn": "provide crn of the COS storage"
                },
                client.spaces.ConfigurationMetaNames.COMPUTE: {
                    "name": "test_instance",
                    "crn": "provide crn of the instance",
                },
                client.spaces.ConfigurationMetaNames.STAGE: {
                    "production": True,
                    "name": "stage_name",
                },
                client.spaces.ConfigurationMetaNames.TAGS: [
                    "sample_tag_1",
                    "sample_tag_2",
                ],
                client.spaces.ConfigurationMetaNames.TYPE: "cpd",
            }
            spaces_details = client.spaces.store(meta_props=metadata)
        """
        ...
    
    async def astore(self, meta_props: dict, background_mode: bool = ...) -> dict:
        """Create a space asynchronously. The instance associated with the space via COMPUTE will be used for billing purposes on
        the cloud. Note that STORAGE and COMPUTE are applicable only for cloud.

        :param meta_props: metadata of the space configuration. To see available meta names, use:

            .. code-block:: python

                client.spaces.ConfigurationMetaNames.get()

        :type meta_props: dict

        :param background_mode: indicator if astore() method will run in background (async) or (sync)
        :type background_mode: bool, optional

        :return: metadata of the stored space
        :rtype: dict

        **Example:**

        .. code-block:: python

            metadata = {
                client.spaces.ConfigurationMetaNames.NAME: "my_space",
                client.spaces.ConfigurationMetaNames.DESCRIPTION: "spaces",
                client.spaces.ConfigurationMetaNames.STORAGE: {
                    "resource_crn": "provide crn of the COS storage"
                },
                client.spaces.ConfigurationMetaNames.COMPUTE: {
                    "name": "test_instance",
                    "crn": "provide crn of the instance",
                },
                client.spaces.ConfigurationMetaNames.STAGE: {
                    "production": True,
                    "name": "stage_name",
                },
                client.spaces.ConfigurationMetaNames.TAGS: [
                    "sample_tag_1",
                    "sample_tag_2",
                ],
                client.spaces.ConfigurationMetaNames.TYPE: "cpd",
            }
            spaces_details = await client.spaces.astore(meta_props=metadata)
        """
        ...
    
    @staticmethod
    def get_id(space_details: dict) -> str:
        """Get the space_id from the space details.

        :param space_details: metadata of the stored space
        :type space_details: dict

        :return: ID of the stored space
        :rtype: str

        **Example:**

        .. code-block:: python

            space_details = client.spaces.store(meta_props)
            space_id = client.spaces.get_id(space_details)
        """
        ...
    
    def get_id_by_name(self, space_name: str) -> str:
        """Get the ID of a stored space by name.

        :param space_name: name of the stored space
        :type space_name: str

        :return: ID of the stored space
        :rtype: str

        **Example:**

        .. code-block:: python

            space_id = client.spaces.get_id_by_name(space_name)

        """
        ...
    
    @staticmethod
    def get_uid(space_details: dict) -> str:
        """Get the unique ID of the space.

         *Deprecated:* Use ``get_id(space_details)`` instead.

         :param space_details: metadata of the space
         :type space_details: dict

         :return: unique ID of the space
         :rtype: str

        **Example:**

        .. code-block:: python

            space_details = client.spaces.store(meta_props)
            space_uid = client.spaces.get_uid(space_details)

        """
        ...
    
    def delete(self, space_id: str) -> Literal["SUCCESS"]:
        """Delete a stored space.

        :param space_id: ID of the space
        :type space_id: str

        :return: status "SUCCESS" if deletion is successful
        :rtype: Literal["SUCCESS"]
        :raises: ApiRequestFailure if deletion failed

        **Example:**

        .. code-block:: python

            client.spaces.delete(space_id)
        """
        ...
    
    async def adelete(self, space_id: str) -> Literal["SUCCESS"]:
        """Delete a stored space asynchronously.

        :param space_id: ID of the space
        :type space_id: str

        :return: status "SUCCESS" if deletion is successful
        :rtype: Literal["SUCCESS"]
        :raises: ApiRequestFailure if deletion failed

        **Example:**

        .. code-block:: python

            await client.spaces.adelete(space_id)
        """
        ...
    
    def get_details(self, space_id: str | None = ..., limit: int | None = ..., asynchronous: bool | None = ..., get_all: bool | None = ..., space_name: str | None = ..., **kwargs: Any) -> dict:
        """Get metadata of stored space(s). The method uses TTL cache.

        :param space_id: ID of the space
        :type space_id: str, optional
        :param limit: applicable when `space_id` is not provided, otherwise `limit` will be ignored
        :type limit: int, optional
        :param asynchronous: if `True`, it will work as a generator
        :type asynchronous: bool, optional
        :param get_all:  if `True`, it will get all entries in 'limited' chunks
        :type get_all: bool, optional
        :param space_name: name of the stored space, can be used only when `space_id` is None
        :type space_name: str, optional

        :return: metadata of stored space(s)
        :rtype:
            - **dict** - if space_id is not None
            - **{"resources": [dict]}** - if space_id is None

        **Example:**

        .. code-block:: python

            space_details = client.spaces.get_details(space_id)
            space_details = client.spaces.get_details(space_name)
            space_details = client.spaces.get_details(limit=100)
            space_details = client.spaces.get_details(limit=100, get_all=True)
            space_details = []
            for entry in client.spaces.get_details(
                limit=100, asynchronous=True, get_all=True
            ):
                space_details.extend(entry)

        """
        ...
    
    async def aget_details(self, space_id: str | None = ..., limit: int | None = ..., asynchronous: bool | None = ..., get_all: bool | None = ..., space_name: str | None = ..., **kwargs: Any) -> dict:
        """Get metadata of stored space(s) asynchronously. The method uses TTL cache.

        :param space_id: ID of the space
        :type space_id: str, optional
        :param limit: applicable when `space_id` is not provided, otherwise `limit` will be ignored
        :type limit: int, optional
        :param asynchronous: if `True`, it will work as a generator
        :type asynchronous: bool, optional
        :param get_all:  if `True`, it will get all entries in 'limited' chunks
        :type get_all: bool, optional
        :param space_name: name of the stored space, can be used only when `space_id` is None
        :type space_name: str, optional

        :return: metadata of stored space(s)
        :rtype:
            - **dict** - if space_id is not None
            - **{"resources": [dict]}** - if space_id is None

        **Example:**

        .. code-block:: python

            space_details = await client.spaces.aget_details(space_id)
            space_details = await client.spaces.aget_details(space_name)
            space_details = await client.spaces.aget_details(limit=100)
            space_details = await client.spaces.aget_details(
                limit=100, get_all=True
            )
            space_details = []
            for entry in await client.spaces.aget_details(
                limit=100, asynchronous=True, get_all=True
            ):
                space_details.extend(entry)

        """
        ...
    
    def list(self, limit: int | None = ..., member: str | None = ..., roles: str | None = ..., space_type: str | None = ...) -> DataFrame:
        """List stored spaces in a table format.

        :param limit: limit number of fetched records
        :type limit: int, optional
        :param member: filters the result list, only includes spaces where the user with a matching user ID
            is a member
        :type member: str, optional
        :param roles: a list of comma-separated space roles to use to filter the query results,
            must be used in conjunction with the "member" query parameter,
            available values : `admin`, `editor`, `viewer`
        :type roles: str, optional
        :param space_type: filter spaces by their type, available types are 'wx', 'cpd', and 'wca'
        :type space_type: str, optional

        :return: pandas.DataFrame with listed spaces
        :rtype: pandas.DataFrame

        **Example:**

        .. code-block:: python

            client.spaces.list()
        """
        ...
    
    def update(self, space_id: str, changes: dict) -> dict:
        """Update existing space metadata. 'STORAGE' cannot be updated.
        STORAGE and COMPUTE are applicable only for cloud.

        :param space_id: ID of the space with the definition to be updated
        :type space_id: str
        :param changes: elements to be changed, where keys are ConfigurationMetaNames
        :type changes: dict

        :return: metadata of the updated space
        :rtype: dict

        **Example:**

        .. code-block:: python

            metadata = {
                client.spaces.ConfigurationMetaNames.NAME: "updated_space",
                client.spaces.ConfigurationMetaNames.COMPUTE: {
                    "name": "test_instance",
                    "crn": "v1:staging:public:pm-20-dev:us-south:a/09796a1b4cddfcc9f7fe17824a68a0f8:f1026e4b-77cf-4703-843d-c9984eac7272::",
                },
            }
            space_details = client.spaces.update(space_id, changes=metadata)
        """
        ...
    
    async def aupdate(self, space_id: str, changes: dict) -> dict:
        """Update existing space metadata asynchronously. 'STORAGE' cannot be updated.
        STORAGE and COMPUTE are applicable only for cloud.

        :param space_id: ID of the space with the definition to be updated
        :type space_id: str
        :param changes: elements to be changed, where keys are ConfigurationMetaNames
        :type changes: dict

        :return: metadata of the updated space
        :rtype: dict

        **Example:**

        .. code-block:: python

            metadata = {
                client.spaces.ConfigurationMetaNames.NAME: "updated_space",
                client.spaces.ConfigurationMetaNames.COMPUTE: {
                    "name": "test_instance",
                    "crn": "v1:staging:public:pm-20-dev:us-south:a/09796a1b4cddfcc9f7fe17824a68a0f8:f1026e4b-77cf-4703-843d-c9984eac7272::",
                },
            }
            space_details = await client.spaces.aupdate(space_id, changes=metadata)
        """
        ...
    
    def create_member(self, space_id: str, meta_props: dict) -> dict:
        """Create a member within a space.

        :param space_id: ID of the space with the definition to be updated
        :type space_id: str
        :param meta_props: metadata of the member configuration. To see available meta names, use:

            .. code-block:: python

                client.spaces.MemberMetaNames.get()

        :type meta_props: dict

        :return: metadata of the stored member
        :rtype: dict

        .. note::
            * `role` can be any one of the following: "viewer", "editor", "admin"
            * `type` can be any one of the following: "user", "service"
            * `id` can be one of the following: service-ID or IAM-userID

        **Examples**

        .. code-block:: python

            metadata = {
                client.spaces.MemberMetaNames.MEMBERS: [
                    {"id": "IBMid-100000DK0B", "type": "user", "role": "admin"}
                ]
            }
            members_details = client.spaces.create_member(
                space_id=space_id, meta_props=metadata
            )

        .. code-block:: python

            metadata = {
                client.spaces.MemberMetaNames.MEMBERS: [
                    {
                        "id": "iam-ServiceId-5a216e59-6592-43b9-8669-625d341aca71",
                        "type": "service",
                        "role": "admin",
                    }
                ]
            }
            members_details = client.spaces.create_member(
                space_id=space_id, meta_props=metadata
            )
        """
        ...
    
    async def acreate_member(self, space_id: str, meta_props: dict) -> dict:
        """Create a member within a space asynchronously.

        :param space_id: ID of the space with the definition to be updated
        :type space_id: str
        :param meta_props: metadata of the member configuration. To see available meta names, use:

            .. code-block:: python

                client.spaces.MemberMetaNames.get()

        :type meta_props: dict

        :return: metadata of the stored member
        :rtype: dict

        .. note::
            * `role` can be any one of the following: "viewer", "editor", "admin"
            * `type` can be any one of the following: "user", "service"
            * `id` can be one of the following: service-ID or IAM-userID

        **Examples**

        .. code-block:: python

            metadata = {
                client.spaces.MemberMetaNames.MEMBERS: [
                    {"id": "IBMid-100000DK0B", "type": "user", "role": "admin"}
                ]
            }
            members_details = await client.spaces.acreate_member(
                space_id=space_id, meta_props=metadata
            )

        .. code-block:: python

            metadata = {
                client.spaces.MemberMetaNames.MEMBERS: [
                    {
                        "id": "iam-ServiceId-5a216e59-6592-43b9-8669-625d341aca71",
                        "type": "service",
                        "role": "admin",
                    }
                ]
            }
            members_details = await client.spaces.acreate_member(
                space_id=space_id, meta_props=metadata
            )
        """
        ...
    
    def get_member_details(self, space_id: str, member_id: str) -> dict:
        """Get metadata of a member associated with a space.

        :param space_id: ID of that space with the definition to be updated
        :type space_id: str
        :param member_id: ID of the member
        :type member_id: str

        :return: metadata of the space member
        :rtype: dict

        **Example:**

        .. code-block:: python

            member_details = client.spaces.get_member_details(space_id, member_id)
        """
        ...
    
    async def aget_member_details(self, space_id: str, member_id: str) -> dict:
        """Get metadata of a member associated with a space asynchronously.

        :param space_id: ID of that space with the definition to be updated
        :type space_id: str
        :param member_id: ID of the member
        :type member_id: str

        :return: metadata of the space member
        :rtype: dict

        **Example:**

        .. code-block:: python

            member_details = await client.spaces.aget_member_details(
                space_id, member_id
            )
        """
        ...
    
    def delete_member(self, space_id: str, member_id: str) -> str:
        """Delete a member associated with a space.

        :param space_id: ID of the space
        :type space_id: str
        :param member_id: ID of the member
        :type member_id: str

        :return: status "SUCCESS" if deletion is successful
        :rtype: Literal["SUCCESS"]
        :raises: ApiRequestFailure if deletion failed

        **Example:**

        .. code-block:: python

            client.spaces.delete_member(space_id, member_id)
        """
        ...
    
    async def adelete_member(self, space_id: str, member_id: str) -> str:
        """Delete a member associated with a space asynchronously.

        :param space_id: ID of the space
        :type space_id: str
        :param member_id: ID of the member
        :type member_id: str

        :return: status "SUCCESS" if deletion is successful
        :rtype: Literal["SUCCESS"]
        :raises: ApiRequestFailure if deletion failed

        **Example:**

        .. code-block:: python

            await client.spaces.adelete_member(space_id, member_id)
        """
        ...
    
    def update_member(self, space_id: str, member_id: str, changes: dict) -> dict:
        """Update the metadata of an existing member.

        :param space_id: ID of the space
        :type space_id: str
        :param member_id: ID of the member to be updated
        :type member_id: str
        :param changes: elements to be changed, where keys are ConfigurationMetaNames
        :type changes: dict

        :return: metadata of the updated member
        :rtype: dict

        **Example:**

        .. code-block:: python

            metadata = {client.spaces.MemberMetaNames.MEMBER: {"role": "editor"}}
            member_details = client.spaces.update_member(
                space_id, member_id, changes=metadata
            )
        """
        ...
    
    async def aupdate_member(self, space_id: str, member_id: str, changes: dict) -> dict:
        """Update the metadata of an existing member asynchronously.

        :param space_id: ID of the space
        :type space_id: str
        :param member_id: ID of the member to be updated
        :type member_id: str
        :param changes: elements to be changed, where keys are ConfigurationMetaNames
        :type changes: dict

        :return: metadata of the updated member
        :rtype: dict

        **Example:**

        .. code-block:: python

            metadata = {client.spaces.MemberMetaNames.MEMBER: {"role": "editor"}}
            member_details = await client.spaces.aupdate_member(
                space_id, member_id, changes=metadata
            )
        """
        ...
    
    def list_members(self, space_id: str, limit: int | None = ..., identity_type: str | None = ..., role: str | None = ..., state: str | None = ...) -> DataFrame:
        """Print the stored members of a space in a table format.

        :param space_id: ID of the space
        :type space_id: str
        :param limit: limit number of fetched records
        :type limit: int, optional
        :param identity_type: filter the members by type
        :type identity_type: str, optional
        :param role: filter the members by role
        :type role: str, optional
        :param state: filter the members by state
        :type state: str, optional

        :return: pandas.DataFrame with listed members
        :rtype: pandas.DataFrame

        **Example:**

        .. code-block:: python

            client.spaces.list_members(space_id)
        """
        ...
    
    def promote(self, asset_id: str, source_project_id: str, target_space_id: str, rev_id: str | None = ...) -> str:
        """Promote an asset from a project to a space.

        :param asset_id: ID of the stored asset
        :type asset_id: str

        :param source_project_id: source project, from which the asset is promoted
        :type source_project_id: str

        :param target_space_id: target space, where the asset is promoted
        :type target_space_id: str

        :param rev_id: revision ID of the promoted asset
        :type rev_id: str, optional

        :return: ID of the promoted asset
        :rtype: str

        **Examples**

        .. code-block:: python

            promoted_asset_id = client.spaces.promote(
                asset_id, source_project_id=project_id, target_space_id=space_id
            )
            promoted_model_id = client.spaces.promote(
                model_id, source_project_id=project_id, target_space_id=space_id
            )
            promoted_function_id = client.spaces.promote(
                function_id, source_project_id=project_id, target_space_id=space_id
            )
            promoted_data_asset_id = client.spaces.promote(
                data_asset_id,
                source_project_id=project_id,
                target_space_id=space_id,
            )
            promoted_connection_asset_id = client.spaces.promote(
                connection_id,
                source_project_id=project_id,
                target_space_id=space_id,
            )
        """
        ...
    
    async def apromote(self, asset_id: str, source_project_id: str, target_space_id: str, rev_id: str | None = ...) -> str:
        """Promote an asset from a project to a space asynchronously.

        :param asset_id: ID of the stored asset
        :type asset_id: str

        :param source_project_id: source project, from which the asset is promoted
        :type source_project_id: str

        :param target_space_id: target space, where the asset is promoted
        :type target_space_id: str

        :param rev_id: revision ID of the promoted asset
        :type rev_id: str, optional

        :return: ID of the promoted asset
        :rtype: str

        **Examples**

        .. code-block:: python

            promoted_asset_id = await client.spaces.apromote(
                asset_id, source_project_id=project_id, target_space_id=space_id
            )
            promoted_model_id = await client.spaces.apromote(
                model_id, source_project_id=project_id, target_space_id=space_id
            )
            promoted_function_id = await client.spaces.apromote(
                function_id, source_project_id=project_id, target_space_id=space_id
            )
            promoted_data_asset_id = await client.spaces.apromote(
                data_asset_id,
                source_project_id=project_id,
                target_space_id=space_id,
            )
            promoted_connection_asset_id = await client.spaces.apromote(
                connection_id,
                source_project_id=project_id,
                target_space_id=space_id,
            )
        """
        ...
    


