"""
This type stub file was generated by pyright.
"""

from pathlib import Path
from typing import Any, TYPE_CHECKING
from ibm_watsonx_ai.utils.enums import AssetDuplicateAction
from ibm_watsonx_ai.wml_resource import WMLResource
from pandas import DataFrame
from ibm_watsonx_ai import APIClient

if TYPE_CHECKING:
    ...
class Assets(WMLResource):
    """Store and manage data assets."""
    ConfigurationMetaNames = ...
    def __init__(self, client: APIClient) -> None:
        ...
    
    def get_details(self, asset_id: str | None = ..., get_all: bool | None = ..., limit: int | None = ..., **kwargs: Any) -> dict:
        """Get data asset details. If no asset_id is passed, details for all assets are returned.

        :param asset_id: unique ID of the asset
        :type asset_id: str, optional

        :param limit:  limit number of fetched records
        :type limit: int, optional

        :param get_all:  if True, it will get all entries in 'limited' chunks
        :type get_all: bool, optional

        :return: metadata of the stored data asset
        :rtype: dict

        **Example:**

        .. code-block:: python

            asset_details = client.data_assets.get_details(asset_id)

        """
        ...
    
    async def aget_details(self, asset_id: str | None = ..., get_all: bool | None = ..., limit: int | None = ...) -> dict:
        """Get data asset details asynchronously. If no asset_id is passed, details for all assets are returned.

        :param asset_id: unique ID of the asset
        :type asset_id: str, optional

        :param limit:  limit number of fetched records
        :type limit: int, optional

        :param get_all:  if True, it will get all entries in 'limited' chunks
        :type get_all: bool, optional

        :return: metadata of the stored data asset
        :rtype: dict

        **Example:**

        .. code-block:: python

            asset_details = await client.data_assets.aget_details(asset_id)

        """
        ...
    
    def create(self, name: str, file_path: str | Path, duplicate_action: AssetDuplicateAction | None = ...) -> dict[str, Any]:
        """Create a data asset and upload content to it.

        :param name: name to be given to the data asset
        :type name: str

        :param file_path: path to the content file to be uploaded
        :type file_path: str | Path

        :param duplicate_action: determines behaviour when asset with the same name already exists,
            if not specified, the value from catalogs/projects/spaces will be used
        :type duplicate_action: AssetDuplicateAction, optional

        :return: metadata of the stored data asset
        :rtype: dict

        **Example:**

        .. code-block:: python

            asset_details = client.data_assets.create(
                name="sample_asset", file_path="/path/to/file"
            )

        """
        ...
    
    async def acreate(self, name: str, file_path: str | Path, duplicate_action: AssetDuplicateAction | None = ...) -> dict[str, Any]:
        """Create a data asset and upload content to it asynchronously.

        :param name: name to be given to the data asset
        :type name: str

        :param file_path: path to the content file to be uploaded
        :type file_path: str

        :param duplicate_action: determines behaviour when asset with the same name already exists,
            if not specified, the value from catalogs/projects/spaces will be used
        :type duplicate_action: AssetDuplicateAction, optional

        :return: metadata of the stored data asset
        :rtype: dict

        **Example:**

        .. code-block:: python

            asset_details = await client.data_assets.acreate(
                name="sample_asset", file_path="/path/to/file"
            )

        """
        ...
    
    def store(self, meta_props: dict) -> dict[str, Any]:
        """Create a data asset and upload content to it.

        :param meta_props: metadata of the space configuration. To see available meta names, use:

            .. code-block:: python

                client.data_assets.ConfigurationMetaNames.get()

        :type meta_props: dict

        **Example:**

        Example of data asset creation for files:

        .. code-block:: python

            metadata = {
                client.data_assets.ConfigurationMetaNames.NAME: "my data assets",
                client.data_assets.ConfigurationMetaNames.DESCRIPTION: "sample description",
                client.data_assets.ConfigurationMetaNames.DATA_CONTENT_NAME: "sample.csv",
            }
            asset_details = client.data_assets.store(meta_props=metadata)

        Example of data asset creation using a connection:

        .. code-block:: python

            metadata = {
                client.data_assets.ConfigurationMetaNames.NAME: "my data assets",
                client.data_assets.ConfigurationMetaNames.DESCRIPTION: "sample description",
                client.data_assets.ConfigurationMetaNames.CONNECTION_ID: "39eaa1ee-9aa4-4651-b8fe-95d3ddae",
                client.data_assets.ConfigurationMetaNames.DATA_CONTENT_NAME: "t1/sample.csv",
            }
            asset_details = client.data_assets.store(meta_props=metadata)

        Example of data asset creation with a database sources type connection:

        .. code-block:: python

            metadata = {
                client.data_assets.ConfigurationMetaNames.NAME: "my data assets",
                client.data_assets.ConfigurationMetaNames.DESCRIPTION: "sample description",
                client.data_assets.ConfigurationMetaNames.CONNECTION_ID: "23eaf1ee-96a4-4651-b8fe-95d3dadfe",
                client.data_assets.ConfigurationMetaNames.DATA_CONTENT_NAME: "t1",
            }
            asset_details = client.data_assets.store(meta_props=metadata)

        """
        ...
    
    async def astore(self, meta_props: dict) -> dict[str, Any]:
        """Create a data asset and upload content to it asynchronously.

        :param meta_props: metadata of the space configuration. To see available meta names, use:

            .. code-block:: python

                client.data_assets.ConfigurationMetaNames.get()

        :type meta_props: dict

        **Example:**

        Example of data asset creation for files:

        .. code-block:: python

            metadata = {
                client.data_assets.ConfigurationMetaNames.NAME: "my data assets",
                client.data_assets.ConfigurationMetaNames.DESCRIPTION: "sample description",
                client.data_assets.ConfigurationMetaNames.DATA_CONTENT_NAME: "sample.csv",
            }
            asset_details = await client.data_assets.astore(meta_props=metadata)

        Example of data asset creation using a connection:

        .. code-block:: python

            metadata = {
                client.data_assets.ConfigurationMetaNames.NAME: "my data assets",
                client.data_assets.ConfigurationMetaNames.DESCRIPTION: "sample description",
                client.data_assets.ConfigurationMetaNames.CONNECTION_ID: "39eaa1ee-9aa4-4651-b8fe-95d3ddae",
                client.data_assets.ConfigurationMetaNames.DATA_CONTENT_NAME: "t1/sample.csv",
            }
            asset_details = await client.data_assets.astore(meta_props=metadata)

        Example of data asset creation with a database sources type connection:

        .. code-block:: python

            metadata = {
                client.data_assets.ConfigurationMetaNames.NAME: "my data assets",
                client.data_assets.ConfigurationMetaNames.DESCRIPTION: "sample description",
                client.data_assets.ConfigurationMetaNames.CONNECTION_ID: "23eaf1ee-96a4-4651-b8fe-95d3dadfe",
                client.data_assets.ConfigurationMetaNames.DATA_CONTENT_NAME: "t1",
            }
            asset_details = await client.data_assets.astore(meta_props=metadata)

        """
        ...
    
    def list(self, limit: int | None = ...) -> DataFrame:
        """Lists stored data assets in a table format.

        :param limit: limit number for fetched records
        :type limit: int, optional

        :rtype: DataFrame
        :return: listed elements

        **Example:**

        .. code-block:: python

            client.data_assets.list()

        """
        ...
    
    def download(self, asset_id: str | None = ..., filename: str | Path | None = ..., **kwargs: Any) -> str:
        """Download and store the content of a data asset.

        :param asset_id: unique ID of the data asset to be downloaded
        :type asset_id: str

        :param filename: filename to be used for the downloaded file
        :type filename: str | Path

        :return: normalized path to the downloaded asset content
        :rtype: str

        **Example:**

        .. code-block:: python

            client.data_assets.download(asset_id, "sample_asset.csv")

        """
        ...
    
    async def adownload(self, asset_id: str, filename: str | Path) -> str:
        """Download and store the content of a data asset asynchronously.

        :param asset_id: unique ID of the data asset to be downloaded
        :type asset_id: str

        :param filename: filename to be used for the downloaded file
        :type filename: str | Path

        :return: normalized path to the downloaded asset content
        :rtype: str

        **Example:**

        .. code-block:: python

            await client.data_assets.adownload(asset_id, "sample_asset.csv")

        """
        ...
    
    def get_content(self, asset_id: str | None = ..., **kwargs: Any) -> bytes:
        """Download the content of a data asset.

        :param asset_id: unique ID of the data asset to be downloaded
        :type asset_id: str

        :return: the asset content
        :rtype: bytes

        **Example:**

        .. code-block:: python

            content = client.data_assets.get_content(asset_id).decode("ascii")

        """
        ...
    
    async def aget_content(self, asset_id: str) -> bytes:
        """Download the content of a data asset asynchronously.

        :param asset_id: unique ID of the data asset to be downloaded
        :type asset_id: str

        :return: the asset content
        :rtype: bytes

        **Example:**

        .. code-block:: python

            content = (await client.data_assets.aget_content(asset_id)).decode(
                "ascii"
            )

        """
        ...
    
    @staticmethod
    def get_id(asset_details: dict) -> str:
        """Get the unique ID of a stored data asset.

        :param asset_details: details of the stored data asset
        :type asset_details: dict

        :return: unique ID of the stored data asset
        :rtype: str

        **Example:**

        .. code-block:: python

            asset_id = client.data_assets.get_id(asset_details)

        """
        ...
    
    @staticmethod
    def get_href(asset_details: dict) -> str:
        """Get the URL of a stored data asset.

        :param asset_details: details of the stored data asset
        :type asset_details: dict

        :return: href of the stored data asset
        :rtype: str

        **Example:**

        .. code-block:: python

            asset_details = client.data_assets.get_details(asset_id)
            asset_href = client.data_assets.get_href(asset_details)

        """
        ...
    
    def delete(self, asset_id: str | None = ..., purge_on_delete: bool | None = ..., **kwargs: Any) -> dict | str:
        """Soft delete the stored data asset. The asset will be moved to trashed assets
        and will not be visible in asset list. To permanently delete assets set `purge_on_delete` parameter to True.

        :param asset_id: unique ID of the data asset
        :type asset_id: str

        :param purge_on_delete: if set to True will purge the asset
        :type purge_on_delete: bool, optional

        :return: status ("SUCCESS" or "FAILED") or dictionary, if deleted asynchronously
        :rtype: str or dict

        **Example:**

        .. code-block:: python

            client.data_assets.delete(asset_id)

        """
        ...
    
    async def adelete(self, asset_id: str, purge_on_delete: bool | None = ...) -> dict | str:
        """Soft delete the stored data asset asynchronously. The asset will be moved to trashed assets
        and will not be visible in asset list. To permanently delete assets set `purge_on_delete` parameter to True.

        :param asset_id: unique ID of the data asset
        :type asset_id: str

        :param purge_on_delete: if set to True will purge the asset
        :type purge_on_delete: bool, optional

        :return: status ("SUCCESS" or "FAILED") or dictionary, if deleted asynchronously
        :rtype: str or dict

        **Example:**

        .. code-block:: python

            await client.data_assets.adelete(asset_id)

        """
        ...
    


