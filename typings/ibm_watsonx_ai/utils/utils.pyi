"""
This type stub file was generated by pyright.
"""

import json
import httpx
import ibm_watsonx_ai._wrappers.requests as requests
import collections
import numpy
import pyspark
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Any, AsyncGenerator, Callable, Generator, TYPE_CHECKING, Type, TypeAlias
from ibm_watsonx_ai import APIClient
from types import TracebackType
from IPython.display import HTML

if TYPE_CHECKING:
    PipelineType: TypeAlias = Any
    MLModelType: TypeAlias = Any
INSTANCE_DETAILS_TYPE = ...
PIPELINE_DETAILS_TYPE = ...
DEPLOYMENT_DETAILS_TYPE = ...
EXPERIMENT_RUN_DETAILS_TYPE = ...
MODEL_DETAILS_TYPE = ...
DEFINITION_DETAILS_TYPE = ...
EXPERIMENT_DETAILS_TYPE = ...
TRAINING_RUN_DETAILS_TYPE = ...
FUNCTION_DETAILS_TYPE = ...
DATA_ASSETS_DETAILS_TYPE = ...
SW_SPEC_DETAILS_TYPE = ...
HW_SPEC_DETAILS_TYPE = ...
RUNTIME_SPEC_DETAILS_TYPE = ...
LIBRARY_DETAILS_TYPE = ...
SPACES_DETAILS_TYPE = ...
MEMBER_DETAILS_TYPE = ...
CONNECTION_DETAILS_TYPE = ...
PKG_EXTN_DETAILS_TYPE = ...
UNKNOWN_ARRAY_TYPE = ...
UNKNOWN_TYPE = ...
SPACES_IMPORTS_DETAILS_TYPE = ...
SPACES_EXPORTS_DETAILS_TYPE = ...
SPARK_MLLIB = ...
SPSS_FRAMEWORK = ...
TENSORFLOW_FRAMEWORK = ...
XGBOOST_FRAMEWORK = ...
SCIKIT_LEARN_FRAMEWORK = ...
PMML_FRAMEWORK = ...
@dataclass
class HttpClientConfig:
    """
    A class for storing parameters used to initialize an `httpx.Client`.
    Using this class is recommended when adjusting timeouts or limits instead of providing a separate `httpx.Client`.
    :param timeout: The timeout configuration for sending requests.
    :type timeout: httpx.Timeout, optional

    :param limits: The limits configuration to control the connection pool size.
    :type limits: httpx.Limits, optional
    """
    timeout: float | Timeout = ...
    limits: Limits = ...


DEFAULT_HTTP_CLIENT_CONFIG = ...
def print_text_header_h1(title: str) -> None:
    ...

def print_text_header_h2(title: str) -> None:
    ...

def get_type_of_details(details: dict) -> str:
    ...

def load_model_from_directory(framework: dict, directory_path: str | Path) -> pyspark.ml.pipeline.PipelineModel | None:
    ...

def save_model_to_file(model: MLModelType, framework: str, base_path: str | Path, filename: str | Path) -> None:
    ...

def format_metrics(latest_metrics_list: list[dict]) -> str:
    ...

def inherited_docstring(f: Callable, mapping: dict | None = ..., actual_type_override: str | None = ...) -> Callable:
    ...

def group_metrics(metrics: list[dict]) -> list | collections.defaultdict:
    ...

class StatusLogger:
    def __init__(self, initial_state: str) -> None:
        ...
    
    def log_state(self, state: str) -> None:
        ...
    
    def __enter__(self) -> StatusLogger:
        ...
    
    def __exit__(self, exc_type: Type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> None:
        ...
    


def get_file_from_cos(cos_credentials: dict) -> str:
    ...

def extract_model_from_repository(model_id: str, client: APIClient, **kwargs: Any) -> str:
    """Download and extract archived model from wml repository.

    :param model_id: ID of model
    :type model_id: str
    :param client: client instance
    :type client: APIClient

    :return: extracted directory path
    :rtype: str
    """
    ...

def extract_mlmodel_from_archive(archive_path: str | Path, model_id: str, **kwargs: Any) -> str:
    """Extract archived model under model id directory.

    :param model_id: ID of model
    :type model_id: str
    :param archive_path: path to archived model
    :type archive_path: str | Path

    :return: extracted directory path
    :rtype: str
    """
    ...

def get_model_filename(directory: str, model_extension: str) -> str:
    ...

def delete_directory(directory: str) -> None:
    ...

def create_empty_directory(directory: str) -> None:
    ...

def install_package(package: str) -> None:
    ...

def is_ipython() -> bool:
    ...

def create_download_link(file_path: str | Path, title: str = ...) -> HTML | None:
    ...

def convert_metadata_to_parameters(meta_data: dict) -> list:
    ...

def is_of_python_basic_type(el: object | list | None) -> bool:
    ...

def next_resource_generator(client: APIClient, url: str, href: str, params: dict | None = ..., _all: bool = ..., _filter_func: Callable | None = ..., use_httpx: bool = ..., _silent_response_logging: bool = ...) -> Generator[dict, None, None]:
    """
    Generator to produce next list of resources from REST API.

    :param client: Client Instance
    :type client: APIClient

    :param url: URL to the resource
    :type url: str

    :param href: href to the resource
    :type href: str

    :param params: parameters of request
    :type params: dict

    :param _all: if `True`, it will get all entries in 'limited' chunks
    :type _all: bool, optional

    :param _filter_func: filtering function
    :type _filter_func: function, optional

    :param use_httpx: use httpx.Client
    :type use_httpx: bool, optional
    """
    ...

async def anext_resource_generator(client: APIClient, url: str, href: str, params: dict | None = ..., _all: bool = ..., _filter_func: Callable | None = ..., _silent_response_logging: bool = ...) -> AsyncGenerator[dict, None]:
    """
    Generator to produce next list of resources from REST API asynchronously.

    :param client: api client Instance
    :type client: APIClient

    :param url: url to the resource
    :type url: str

    :param href: href to the resource
    :type href: str

    :param params: parameters of request
    :type params: dict

    :param _all: if `True`, it will get all entries in 'limited' chunks
    :type _all: bool, optional

    :param _filter_func: filtering function
    :type _filter_func: function, optional
    """
    ...

class DisableWarningsLogger:
    """Class which disables logging warnings (for example for silent handling WMLClientErrors in try except).

    **Example:**

    .. code-block:: python

        try:
            with DisableWarningsLogger():
                throw_wml_error()
        except WMLClientError:
            success = False

    """
    def __enter__(self) -> None:
        ...
    
    def __exit__(self, exit_type: Type[BaseException] | None, exit_value: BaseException | None, exit_traceback: TracebackType | None) -> None:
        ...
    


def is_lib_installed(lib_name: str, minimum_version: str | None = ..., install: bool = ...) -> bool:
    """Check if provided library is installed on user environment. If not, tries to install it.

    :param lib_name: library name to check
    :type lib_name: str

    :param minimum_version: minimum version of library to check, default: None - check if library is installed in overall
    :type minimum_version: str, optional

    :param install: indicates to install missing or to low version library
    :type install: bool, optional

    :return: information if library is installed: `True` is library is installed, `False` otherwise
    :rtype: bool
    """
    ...

def install_library(lib_name: str, version: str | None = ..., strict: bool = ...) -> None:
    """Try to install library.

    :param lib_name: library name to install
    :type lib_name: str

    :param version: version of the library to install
    :type version: str, optional

    :param strict: indicates if we want to install specific version or higher version if available
    :type strict: bool, optional
    """
    ...

def get_module_version(lib_name: str) -> str:
    """Use only when you need to check package version by package name with pip."""
    ...

def normalize_lib_name(name: str) -> str:
    """Helper to standardize library names for comparison or lookup.

    :param name: the original library name
    :type name: str

    :return: normalized library name
    :rtype: str
    """
    ...

def find_installed_version(lib_name: str) -> str | None:
    """Find the installed version of a given library, if available.

    :param lib_name: library name to check
    :type lib_name: str

    :return: installed version as a string if found, otherwise None
    :rtype: str | None
    """
    ...

def ensure_submodule_available(package: str, submodule: str, extra_hint: str | None = ...): # -> None:
    """Checks whether the specified submodule can be imported. If it is not available,
    raises a `MissingExtension` error.

    :param package: main package name
    :type package: str

    :param submodule: submodule name to verify
    :type submodule: str

    :param extra_hint: optional hint to include in the error message
    :type extra_hint: str, optional

    :raises MissingExtension: if the specified submodule cannot be found
    """
    ...

def prepare_interaction_props_for_cos(source_params: dict, file_name: str) -> dict:
    """If user specified properties for dataset as sheet_name, delimiter etc. we need to
    pass them as interaction properties for Flight Service.

    :param source_params: data source parameters describe data (eg. excel_sheet, encoding etc.)
    :type source_params: dict

    :param file_name: name of the file to download, should consist of file extension
    :type file_name: str

    :return: COS interaction properties for Flight Service
    :rtype: dict
    """
    ...

def modify_details_for_script_and_shiny(details_from_get: dict) -> dict:
    """Add the href and id of and asset to the same position as it is returned from the POST method
    it allows the `get_id`/`get_href` method to work with details returned by GET method.

    :param details_from_get: details of script/shiny app acquired using GET method
    :type details_from_get: dict

    :return: details with 'guid' and 'href' key added to 'metadata'
    :rtype: dict
    """
    ...

def is_lale_pipeline(pipeline: PipelineType) -> bool:
    ...

class NumpyTypeEncoder(json.JSONEncoder):
    """Extended json.JSONEncoder to encode correctly numpy types."""
    def default(self, obj: numpy.integer | numpy.bool_ | numpy.floating | numpy.ndarray) -> int | bool | float | list | None:
        ...
    


def get_user_agent_header() -> str:
    """
    Function which return User-Agent header
    """
    ...

class StrEnum(str, Enum):
    """
    External class created for the needs of auto-generated enums

    UseCase of StrEnum:
    When we call print function on StrEnum attribute we are getting value ot them instead of Enum object

    Example of StrEnum
    TestEnum.Enum1 == "enum1" --> True

    Example of Enum
    TestEnum.Enum1 == "enum1 --> False
    """
    def __str__(self) -> str:
        ...
    
    @classmethod
    def show(cls) -> None:
        ...
    


class _APIClientSession(requests.Session):
    """Wrapper for requests.Session to use in APIClient initialization."""
    def __init__(self, client: APIClient) -> None:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    


def raise_exception_about_unsupported_on_cloud(func: Callable) -> Callable:
    ...

def content_type_for(filepath: str | Path, default: str = ...) -> str:
    """
    Return the bestâ€guess Content-Type for a file path, falling back to `default` if unknown.
    """
    ...

def get_filename_from_asset_details(asset_details: dict) -> str | None:
    """Return filename from asset details."""
    ...

GOV_CLOUD_CONSENT_FORMULA = ...
class AsyncFileReader(httpx.AsyncByteStream):
    """File reader for async httpx requests."""
    def __init__(self, file_path: str | Path, chunk_size: int = ...) -> None:
        ...
    
    async def __aiter__(self) -> AsyncGenerator[bytes, None]:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    


def get_from_json(json_object: Any, key_chain: list[Any], default: Any = ...) -> Any:
    ...

